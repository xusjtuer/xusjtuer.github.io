<html>
<head>
    <meta charset="utf-8"/>
<meta name="description" content=""/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<title>UE4 基于CustomThunk的泛型蓝图节点语法规范 (一) | 童年的琴-博客</title>

<link rel="shortcut icon" href="https://xusjtuer.github.io/favicon.ico?v=1601206470504">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://xusjtuer.github.io/styles/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcss.com/highlight.js/9.15.10/languages/dart.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script>
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->


    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-179084332-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }

        gtag('js', new Date());
        gtag('config', 'UA-179084332-1');
    </script>


    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
	
	<script>
	var _hmt = _hmt || [];
	(function() {
	  var hm = document.createElement("script");
	  hm.src = "https://hm.baidu.com/hm.js?762fab8d66e007c3dd8e239a6deba5f1";
	  var s = document.getElementsByTagName("script")[0]; 
	  s.parentNode.insertBefore(hm, s);
	})();
	</script>

</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <div class="navbar-brand">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            童年的琴-博客
        </div>
    </div>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
                <div class="nav-item">
                    
                        <a href="/" class="menu gt-a-link">
                            首页
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/archives" class="menu gt-a-link">
                            归档
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/tags" class="menu gt-a-link">
                            标签
                        </a>
                    
                </div>
            
                <div class="nav-item">
                    
                        <a href="/post/about" class="menu gt-a-link">
                            关于
                        </a>
                    
                </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1601206470504" action="/search/index.html">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    UE4 基于CustomThunk的泛型蓝图节点语法规范 (一)
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2020-09-14 ·
                    </time>
                    
                        <a href="https://xusjtuer.github.io/tag/JBh2EGYhV/" class="post-tags">
                            # customthunk
                        </a>
                    
                        <a href="https://xusjtuer.github.io/tag/l7UgE4BWu/" class="post-tags">
                            # wildcard
                        </a>
                    
                        <a href="https://xusjtuer.github.io/tag/chYkJdpez/" class="post-tags">
                            # ue4 c++
                        </a>
                    
                        <a href="https://xusjtuer.github.io/tag/I8veTBffD8/" class="post-tags">
                            # generic
                        </a>
                    
                </div>
                <div class="post-content">
                    <h1 id="1-overview"><strong>1. Overview</strong></h1>
<p>本教程旨在讲解基于CustomThunk方式实现泛型蓝图节点的语法规范，主要包括泛型蓝图节点的组成，泛型蓝图节点的声明，自定义Thunk函数体实现，泛型函数（Generic）的实现案例。因内容较多，故分成二期。如觉有帮助，请不吝点赞；如觉无聊，可一带而过。</p>
<h1 id="2-introduction"><strong>2. Introduction</strong></h1>
<p>正如前面二期介绍的泛型蓝图节点的应用实例（SORT和GET/SET），泛型蓝图节点应用广泛，并且极大的扩展了蓝图系统的便利性。不同的类型，相同的操作可以使用同一个蓝图节点来完成，减少了代码冗余。本次教程承接上一期内容，继续介绍基于CustomThunk方法的泛型蓝图节点语法规范和实现方式，以下内容为个人分析源码经验所得，如有错漏，敬请谅解，并欢迎在下方评论区中指出，或补充更多相关信息。</p>
<p>CustomThunk和UK2Node都可以实现泛型蓝图节点，二种实现方法大相径庭，实现难易程度也相差很远，具体选择哪一种方法应当考虑一下情况：</p>
<p>1）meta说明符功能可以满足要求时，建议优先使用CustomThunk方法，理由：代码少，debug方便；</p>
<ol start="2">
<li>以下二种情形，建议使用UK2Node方法：</li>
</ol>
<p>情形一：在编辑模式（Editor）下（非运行状态）需要“修改”蓝图节点引脚（PIN），例如动态增加或删除蓝图节点PIN。</p>
<p>情形二：当使用CustomThunk方式实现的泛型蓝图节点时，程序员对蓝图引脚的控制只有通过meta说明符，而目前meta说明符功能仍存在部分限制。举例，如ue4内置GetDataTableRow蓝图节点一样，该节点的OutRow 引脚（wildcard PIN）需要根据DataTable 引脚输入的DataTable表动态更改OutRow类型；虽然CustomThunk方法也能实现动态改变引脚类型，但是对于此类情况却无法处理。</p>
<h1 id="3-required-knowledge"><strong>3. Required Knowledge</strong></h1>
<ol>
<li>
<p>ue4 c++ 类的创建以及c++中定义蓝图可调用函数；</p>
</li>
<li>
<p>熟悉ue4 c++ UFUNCTION宏中常用说明符以及meta说明符；</p>
</li>
</ol>
<h1 id="4-approach"><strong>4. Approach</strong></h1>
<h2 id="41-泛型蓝图节点c函数组成"><strong>4.1 泛型蓝图节点c++函数组成</strong></h2>
<p>查看UE4源代码（在整个解决方案中查找关键字CustomThunk），不难发现绝大多数泛型的蓝图节点的c++ 实现包括三个组成部分：（1）带有UFUNCTION宏的函数声明；（2） 自定义Thunk函数体DECLARE_FUNCTION(execFunctionName)；（3）真正执行泛型逻辑的Generic_FunctionName()泛型函数。</p>
<p><strong>第（1）部分</strong>，限定了在蓝图系统中该函数以蓝图节点方式出现时的样式，包括函数名、参数列表、返回值以及泛型参数等。UFUNCTION宏中包含CustomThunk说明符，其中泛型参数及依赖关系由meta说明符列表决定。</p>
<p><strong>第（2）部分</strong>，定义了泛型蓝图函数的Thunk函数体，其实质作用在于运行（Runtime）时获取从蓝图虚拟机VM中传递的参数，其形式规定为 DECLARE_FUNCTION(execFunctionName){}， Function Name为第（1） 部分声明的函数名。</p>
<p><strong>第（3）部分</strong>，在完整获得蓝图传递的参数之后，调用蓝图函数的泛型版本，也就是第（3）部分定义的泛型函数。该函数是真正执行泛型功能的代码块，如第2期的数组排序功能，第3期的属性GET/SET功能。此函数命名并无强制性要求，可以选择任意合法的函数名，为了便于理解，源代码中一般采用Generic_（Generic）+ FunctionName的形式，Generic的含义就是通常所说的泛型。</p>
<h2 id="42-泛型蓝图函数声明"><strong>4.2 泛型蓝图函数声明</strong></h2>
<p>如蓝图系统中的变量类型（Variable Type）一样，标识泛型函数通配符(wildcard)参数的说明符也有四种，分别为标识单个变量SingleVariable wildcard类型的&quot;CustomStructureParam&quot;说明符、标识容器Array的&quot;ArrayParm&quot;说明符、标识容器Map的&quot;MapParam&quot;说明符、标识容器Set的&quot;SetParam&quot;说明符以及各种辅助说明符，四种说明符存在部分差异。</p>
<p>以下代码编译运行环境：<strong>UE4 v4.25 / vs2017</strong></p>
<h3 id="1single-variable泛型参数的函数声明示例"><strong>（1）Single Variable泛型参数的函数声明示例</strong></h3>
<pre><code class="language-c++">public: // Wildcard property

	// Declare a function with an wildcard parameter.
	UFUNCTION(BlueprintCallable, CustomThunk, meta = (CustomStructureParam = &quot;Value&quot;), Category = &quot;Utilities|Variadic&quot;)
		static void PropertyFunction1(const int32&amp; Value);
	DECLARE_FUNCTION(execPropertyFunction1) {}

	// The variable marked by &quot;CustomStructureParam&quot; would be a placeholder.
	UFUNCTION(BlueprintCallable, CustomThunk, meta = (CustomStructureParam = &quot;Value&quot;), Category = &quot;Utilities|Variadic&quot;)
		static void PropertyFunction2(UProperty* Value);
	DECLARE_FUNCTION(execPropertyFunction2) {}

	// Declare a function with multiple wildcard parameters.
	UFUNCTION(BlueprintCallable, CustomThunk, meta = (CustomStructureParam = &quot;Value1,Value2,Value&quot;), Category = &quot;Utilities|Variadic&quot;)
		static void PropertyFunction3(const int32&amp; Value1, const int32&amp; Value2, int32&amp; Value);
	DECLARE_FUNCTION(execPropertyFunction3) {}

	// Declare a function with incorrect delimiter        ---&gt; Bad case &lt;---
	UFUNCTION(BlueprintCallable, CustomThunk, meta = (CustomStructureParam = &quot;Value1|Value2&quot;), Category = &quot;Utilities|Variadic&quot;)
		static void PropertyFunction4(const int32&amp; Value1, const int32&amp; Value2);
	DECLARE_FUNCTION(execPropertyFunction4) {}

	// Declare a function with one incorrect type  ---&gt; Bad case &lt;---
	UFUNCTION(BlueprintCallable, CustomThunk, meta = (CustomStructureParam = &quot;Value&quot;), Category = &quot;Utilities|Variadic&quot;)
		static void PropertyFunction5(const TArray&lt;int32&gt;&amp; Value);
	DECLARE_FUNCTION(execPropertyFunction5) {}
</code></pre>
<p>将以上代码拷贝到以UBlueprintFunctionLibrary为基类的C++类的头文件中（.h文件），编译后即可在蓝图系统中找到这5个蓝图节点。</p>
<figure data-type="image" tabindex="1"><img src="https://xusjtuer.github.io/post-images/1601109435296.gif" alt="" loading="lazy"></figure>
<center style="font-size:10px;color:#C0C0C0;text-decoration:none">图1. CustomStructureParam说明符声明的泛型蓝图节点；</center> <br />
<p><strong>Single Variable泛型参数的函数声明规则 ：</strong></p>
<p>（1） UFUNTIION()宏应包含三类说明符：①表示蓝图可调用含义的说明符，如常用的BlueprintCallable、BlueprintPure；② CustomThunk说明符，标识该函数需要自定义Thunk函数体；③被CustomStructureParam说明符所标识的泛型参数列表，其他说明符视情形选择。（见示例PropertyFunction1 / PropertyFunction2 / PropertyFunction5）</p>
<p>（2） 被CustomStructureParam说明符标识的函数参数实为一个占位符，源代码中常用const int32&amp; VariableName表示一个输入类型泛型参数，int32&amp; VariableName表示一个输出类型的泛型参数。（见示例 PropertyFunction3）</p>
<p>（3） CustomStructureParam说明符标识多个泛型变量时，变量之间需以英文逗号”,”作为分隔符，不得包含其他字符，如空格 、”|”等其他字符；否则虽然可以通过vs编译，但是在蓝图系统不会如期显示。（见示例 PropertyFunction4）</p>
<p>（4） 限制：目前，在源代码中并没有存在（或者说没发现）标识多个Single Variable泛型参数之间依赖关系的辅助说明符，也就是不能定义多个Single Variable 泛型参数彼此之间的依赖关系。</p>
<h3 id="2array泛型参数的蓝图函数声明示例"><strong>（2）Array泛型参数的蓝图函数声明示例</strong></h3>
<pre><code class="language-c++">public: // Wildcard TArray

	// Declare a function with one wildcard array parameter.
	UFUNCTION(BlueprintCallable, CustomThunk, meta = (ArrayParm = &quot;Array&quot;), Category = &quot;Utilities|Variadic&quot;)
		static void ArrayFunction1(const TArray&lt;int32&gt;&amp; Array);
	DECLARE_FUNCTION(execArrayFunction1) {}

	// Declare a function with one wildcard array parameter with an type dependent parameter .
	UFUNCTION(BlueprintCallable, CustomThunk, meta = (ArrayParm = &quot;Array&quot;, ArrayTypeDependentParams = &quot;Item&quot;), Category = &quot;Utilities|Variadic&quot;)
		static void ArrayFunction2(const TArray&lt;int32&gt;&amp; Array, const int32&amp; Item);
	DECLARE_FUNCTION(execArrayFunction2) {}

	// Declare a function with multiple wildcard array parameters.
	UFUNCTION(BlueprintCallable, CustomThunk, meta = (ArrayParm = &quot;Array1,Array2,Array3&quot;, ArrayTypeDependentParams = &quot;Array1,Array2,Array3&quot;), Category = &quot;Utilities|Variadic&quot;)
		static void ArrayFunction3(const TArray&lt;int32&gt;&amp; Array1, const TArray&lt;int32&gt;&amp; Array2, TArray&lt;int32&gt;&amp; Array3);
	DECLARE_FUNCTION(execArrayFunction3) {}

	// Declare a function with multiple wildcard array parameters
	UFUNCTION(BlueprintCallable, CustomThunk, meta = (ArrayParm = &quot;Array1,Array2,Array3&quot;, ArrayTypeDependentParams = &quot;Array1,Array3&quot;), Category = &quot;Utilities|Variadic&quot;)
		static void ArrayFunction4(const TArray&lt;int32&gt;&amp; Array1, const TArray&lt;int32&gt;&amp; Array2, TArray&lt;int32&gt;&amp; Array3);
	DECLARE_FUNCTION(execArrayFunction4) {}

	// Declare a function with multiple wildcard array parameters. ---&gt; Bad case &lt;---
	UFUNCTION(BlueprintCallable, CustomThunk, meta = (ArrayParm = &quot;Array1|Array2|Array3&quot;), Category = &quot;Utilities|Variadic&quot;)
		static void ArrayFunction5(const TArray&lt;int32&gt;&amp; Array1, const TArray&lt;int32&gt;&amp; Array2, TArray&lt;int32&gt;&amp; Array3);
	DECLARE_FUNCTION(execArrayFunction5) {}
</code></pre>
<figure data-type="image" tabindex="2"><img src="https://xusjtuer.github.io/post-images/1601109748568.gif" alt="" loading="lazy"></figure>
<center style="font-size:10px;color:#C0C0C0;text-decoration:none">图2. ArrayParm说明符声明的泛型蓝图节点；</center> <br />
<p><strong>Wildcard Array泛型函数声明规则 ：</strong></p>
<p>（1） UFUNTIION()宏应包含三类说明符：①表示蓝图可调用含义的说明符，如常用的BlueprintCallable、BlueprintPure；② CustomThunk说明符，标识该函数需要自定义Thunk函数体；③被说明符ArrayParm所标识的泛型参数（wildcard array）列表，此外还可能包含标识泛型Array参数之间依赖关系的ArrayTypeDependentParams说明符，其他说明符视情形选择。（见示例 ArrayFunction1 / ArrayFunction2 / ArrayFunction3 / ArrayFunction4）</p>
<p>（2） 源代码中常用const TArray<int32>&amp; ArrayName表示一个输入类型的泛型Array参数，TArray<int32>&amp; ArrayName表示一个输出类型的泛型Array参数。（见示例ArrayFunction3）</p>
<p>（3） ArrayParm说明符标识多个泛型参数变量时，变量之间需以英文逗号”,”分隔，不得包含其他字符，否则虽然可以通过编译，但是在蓝图系统中显示异常。（见示例ArrayFunction5）</p>
<p>（4） 被ArrayTypeDependentParams说明符标识的多个泛型Array参数的类型相互依赖，在蓝图图表中被调用时只有确定其中之一，余下泛型Array参数随之变化。 更多泛型Array示例见源码：KismetArrayLibrary.h</p>
<h3 id="3map泛型参数的函数声明示例"><strong>（3）Map泛型参数的函数声明示例</strong></h3>
<pre><code class="language-c++">public: // wildcard TMap

	// Declare a function with one wildcard array parameter.
	UFUNCTION(BlueprintCallable, CustomThunk, meta = (MapParam = &quot;TargetMap&quot;), Category = &quot;Utilities|Variadic&quot;)
		static void MapFunciton1(const TMap&lt;int32, int32&gt;&amp; TargetMap);
	DECLARE_FUNCTION(execMapFunciton1) {}

	// Declare a function with one wildcard map parameter with type dependent parameters.
	UFUNCTION(BlueprintCallable, CustomThunk, meta = (MapParam = &quot;TargetMap&quot;, MapKeyParam = &quot;Key&quot;, MapValueParam = &quot;Value&quot;, AutoCreateRefTerm = &quot;Key, Value&quot;), Category = &quot;Utilities|Variadic&quot;)
		static void MapFunciton2(const TMap&lt;int32, int32&gt;&amp; TargetMap, const int32&amp; Key, const int32&amp; Value);
	DECLARE_FUNCTION(execMapFunciton2) {}

	//UNSUPPORTED ---&gt; Declare a function with multiple wildcard map parameters.
	UFUNCTION(BlueprintCallable, CustomThunk, meta = (MapParam = &quot;TargetMap,SourceMap,ReturnMap&quot;), Category = &quot;Utilities|Variadic&quot;)
		static void MapFunciton3(const TMap&lt;int32, int32&gt;&amp; TargetMap, const TMap&lt;int32, int32&gt;&amp; SourceMap, TMap&lt;int32, int32&gt;&amp; ReturnMap);
	DECLARE_FUNCTION(execMapFunciton3) {}

	//UNSUPPORTED ---&gt; Declare a function with multiple wildcard map parameters.
	UFUNCTION(BlueprintCallable, CustomThunk, meta = (MapParam = &quot;TargetMap|SourceMap|ReturnMap&quot;), Category = &quot;Utilities|Variadic&quot;)
		static void MapFunciton4(const TMap&lt;int32, int32&gt;&amp; TargetMap, const TMap&lt;int32, int32&gt;&amp; SourceMap, TMap&lt;int32, int32&gt;&amp; ReturnMap);
	DECLARE_FUNCTION(execMapFunciton4) {}
</code></pre>
<figure data-type="image" tabindex="3"><img src="https://xusjtuer.github.io/post-images/1601109811115.gif" alt="" loading="lazy"></figure>
<center style="font-size:10px;color:#C0C0C0;text-decoration:none">图3. MapParm说明符声明的泛型蓝图节点；</center> <br />
<p><strong>Wildcard Map泛型函数声明规则 ：</strong></p>
<p>（1） UFUNTIION()宏应包含三类说明符：①表示蓝图可调用含义的说明符，如常用的BlueprintCallable、BlueprintPure；② CustomThunk说明符，标识该函数需要自定义Thunk函数体；③被说明符MapParam所标识的泛型Map参数（wildcard map）列表，其他说明符视情形选择。（见示例 MapFunciton1 / MapFunciton2）</p>
<p>（2） 源代码中常用const TMap<int32>&amp; MapName表示一个输入类型的泛型Map参数，TMap<int32>&amp; MapName表示一个输出类型的泛型Map参数。（见示例 MapFunciton4）</p>
<p>（3） 经试验，声明多个泛型Map参数时无论是采用”,”还是”|”分隔变量，在蓝图系统均出现不同情形的异常情况；以逗号分隔多个泛型Map参数时，蓝图西并没有将这些参数标识为泛型Map引脚。”|”分隔多个参数时，虽然该蓝图节点显示为多个泛型Map引脚，但是当连接上Map类型变量时该引脚并没有更新类型，如上图示例MapFunciton3和 MapFunciton4。<em>不确定这是不是一个引擎bug！？</em></p>
<p>（4） 被MapKeyParam和MapValueParam说明符标识的泛型参数与被MapParam说明符标识的泛型参数相互依赖。 Map没有类似于” ArrayTypeDependentParams”说明符一样标识多个泛型Map参数依赖关系的辅助说明符” MapTypeDependentParams”，（见示例MapFunciton2）。更多泛型Map示例见源码：BlueprintMapLibrary.h。</p>
<h3 id="4set泛型参数的函数声明示例"><strong>（4）Set泛型参数的函数声明示例</strong></h3>
<pre><code class="language-c++">public:// wildcard Set

	// Declare a function with one wildcard Set parameter.
	UFUNCTION(BlueprintCallable, CustomThunk, meta = (SetParam = &quot;TargetSet&quot;), Category = &quot;Utilities|Variadic&quot;)
		static void SetFunciton1(const TSet&lt;int32&gt;&amp; TargetSet);
	DECLARE_FUNCTION(execSetFunciton1) {}

	// Declare a function with one wildcard Set parameter with type independent parameter.
	UFUNCTION(BlueprintCallable, CustomThunk, meta = (SetParam = &quot;TargetSet,NewItem&quot;), Category = &quot;Utilities|Variadic&quot;)
		static void SetFunciton2(const TSet&lt;int32&gt;&amp; TargetSet, const int32&amp; NewItem);
	DECLARE_FUNCTION(execSetFunciton2) {}

	// Declare a function with one wildcard Set parameter with type dependent parameter.
	UFUNCTION(BlueprintCallable, CustomThunk, meta = (SetParam = &quot;TargetSet|NewItem&quot;), Category = &quot;Utilities|Variadic&quot;)
		static void SetFunciton3(const TSet&lt;int32&gt;&amp; TargetSet, const int32&amp; NewItem);
	DECLARE_FUNCTION(execSetFunciton3) {}

	// Declare a function with one wildcard Set parameter and type dependent array parameter
	UFUNCTION(BlueprintCallable, CustomThunk, meta = (SetParam = &quot;TargetSet|NewItems&quot;), Category = &quot;Utilities|Variadic&quot;)
		static void SetFunciton4(const TSet&lt;int32&gt;&amp; TargetSet, const TArray&lt;int32&gt;&amp; NewItems);
	DECLARE_FUNCTION(execSetFunciton4) {}

	// Declare a function with multiple wildcard Set parameters v1
	UFUNCTION(BlueprintCallable, CustomThunk, meta = (SetParam = &quot;Set1|Set2,Set3&quot;), Category = &quot;Utilities|Variadic&quot;)
		static void SetFunciton5(const TSet&lt;int32&gt;&amp; Set1, const TSet&lt;int32&gt;&amp; Set2, TSet&lt;int32&gt;&amp; Set3);
	DECLARE_FUNCTION(execSetFunciton5) {}

	// Declare a function with multiple wildcard Set parameters v2
	UFUNCTION(BlueprintCallable, CustomThunk, meta = (SetParam = &quot;Set1|Set2|Set3&quot;), Category = &quot;Utilities|Variadic&quot;)
		static void SetFunciton6(const TSet&lt;int32&gt;&amp; Set1, const TSet&lt;int32&gt;&amp; Set2, TSet&lt;int32&gt;&amp; Set3);
	DECLARE_FUNCTION(execSetFunciton6) {}
 
</code></pre>
<figure data-type="image" tabindex="4"><img src="https://xusjtuer.github.io/post-images/1601109858456.gif" alt="" loading="lazy"></figure>
<center style="font-size:10px;color:#C0C0C0;text-decoration:none">图4. SetParm说明符声明的泛型蓝图节点；</center> <br />
<p><strong>声明规则 ：</strong></p>
<p>（1） UFUNTIION()宏应包含三类说明符：①表示蓝图可调用含义的说明符，如常用的BlueprintCallable、BlueprintPure；② CustomThunk说明符，标识该函数需要自定义Thunk函数体；③被说明符SetParam所标识的泛型Set参数（wildcard set）列表，其他说明符视情形选择，（见示例SetFunciton1 / SetFunciton2 / SetFunciton3）。</p>
<p>（2） 源代码中常用const TSet<int32>&amp; SetName表示一个输入类型的泛型Set参数，TSet<int32>&amp; SetName表示一个输出类型的泛型Set参数，（见示例SetFunciton1 / SetFunciton5）。</p>
<p>（3） 声明多个泛型Set参数时, SetParam说明符列表的泛型参数之间可以使用”,”和”|”二种分隔符，（见示例SetFunciton2 / SetFunciton3）；SetParam说明符同时也可以标识有依赖关系的泛型Arrary参数，（见示例SetFunciton4）。</p>
<p>（4） 多个泛型参数的依赖关系由分隔符的类型决定，以逗号”,”分隔的多个泛型Set参数之间相互独立，以”|”分隔的多个泛型Set参数之间相互依赖，（见示例SetFunciton5 / SetFunciton6）。更多泛型Set示例见源码：BlueprintSetLibrary.h</p>
<h2 id="43-thunk函数体的实现过程"><strong>4.3 Thunk函数体的实现过程</strong></h2>
<p>如前所述，在UFUNCTION宏中使用了CustomThunk说明符，需要为该函数自定义Thunk函数体。Thunk函数体主要作用：当蓝图节点被调用时，获取从蓝图虚拟机VM中传递来的参数值，并将值传递给执行特定功能的c++函数。</p>
<p>首先了解下Thunk函数体的由来。通常定义在c++类中，并用UFUNCTION宏标识为蓝图可调用的函数；编译时，UHT会在该类的generated.h文件中为其自动生成一个形如DECLARE_FUNCTION(execFunctionName) {}的函数体，也就是我们所说的Thunk函数体。</p>
<p>举例来说，在BlueprintFunctionLibrary中声明如下函数</p>
<pre><code class="language-c++">UFUNCTION(BlueprintPure, BlueprintCallable, Category = &quot;Math|Random&quot;, meta = (DisplayName = &quot;Random Character&quot;, Keywords = &quot;random, char，string&quot;))
	static FString GetRandomCharacter(int32 MinValue = 33, int32 MaxValue = 126);
</code></pre>
<p>generated.h文件中就存在如下代码块</p>
<pre><code class="language-c++">DECLARE_FUNCTION(execGetRandomCharacter) \
	{ \
		P_GET_PROPERTY(UIntProperty, Z_Param_MinValue); \
		P_GET_PROPERTY(UIntProperty, Z_Param_MaxValue); \
		P_FINISH; \
		P_NATIVE_BEGIN; \
		*(FString*)Z_Param__Result = URandomAlgorithm::GetRandomCharacter(Z_Param_MinValue, Z_Param_MaxValue); \
		P_NATIVE_END; \
	}
</code></pre>
<figure data-type="image" tabindex="5"><img src="https://xusjtuer.github.io/post-images/1601109904076.gif" alt="" loading="lazy"></figure>
<center style="font-size:10px;color:#C0C0C0;text-decoration:none">图5. 在generated.h文件中查找Thunk函数体；</center> <br />
<p>Thunk函数体有其特定的语法规则，要想自定义泛型蓝图节点，就必然要学会编写Thunk函数体。熟练掌握Thunk函数体的语法规则，就可以随心所欲的自定义Thunk函数体。Thunk函数体的用途在于Runtime时获取蓝图VM传递过来的参数值，因而Thunk函数的代码是在Runtime时运行的。在自定义Thunk函数体中所使用的宏定义于UObject\ScriptMacros.h文件中。</p>
<p><strong>自定义Thunk函数体包含如下规则：</strong><br>
（1）Thunk函数的基本形式如下， DECLARE_FUNCTION(execFunctionName) {}，FucntionName为函数声明时的函数名称。在花括号{}内部包含的代码：P_FINISH宏之前为获取函数参数的代码块、P_NATIVE_BEGIN和P_NATIVE_END宏包裹着真正执行该函数功能的被调用函数，若是泛型蓝图节点，此处调用该函数的泛型版本（泛型函数）。若函数无返回值，可以直接调用泛型函数；若存在返回值，则应当在&quot;=&quot;左侧定义适当的返回值类型。</p>
<pre><code class="language-c++">DECLARE_FUNCTION(execFunctionName)
{
	// Get Parameters
	P_FINISH;
	P_NATIVE_BEGIN;
	*(FString*)Result = Generic_FunctionName();   // Call generic function
	P_NATIVE_END;
}
</code></pre>
<p>（2）当在Thunk函数体中获取多个参数时，获取的先后次序应与函数声明时变量在参数列表中出现的次序保持一致，否则在函数被调用时将引发程序崩溃。</p>
<p>（3）在Thunk函数体中，泛型蓝图函数的参数列表中确定类型的参数（如bool / uint8 / int32 / float / FName / FString等）和泛型参数（wilcard SingleVariable / TArray / TMap / TSet）获取方式不同。</p>
<h3 id="a获取确定类型的函数参数的代码的编写方法"><strong>a.获取确定类型的函数参数的代码的编写方法：</strong></h3>
<p>如下示例，可以先定义一个带该已知类型的函数，编译后在该类.generated.h文件中找到同名的Thunk体后，并定位到获取该类型参数的代码块。按同样的规则，在自定义的Thunk函数体中，编写获取该参数的代码即可，这种方式对于新手非常有用。</p>
<p>确定类型变量函数声明示例：</p>
<pre><code class="language-c++">UFUNCTION(BlueprintCallable, Category = &quot;MyProject&quot;)
		static void  TestFunction(
		   bool BoolVar
		 , uint8 ByteVar
		 , int32 IntegerVar
		 , float FloatVar
		 , FName NameVar
		 , FString StringVar
		 , const FText&amp; TextVar
		 , FVector VectorVar
		 , FTransform TransformVar
		 , UObject* ObjectVar
		 , TSubclassOf&lt;UObject&gt; ClassVar
		 , bool&amp; RetBoolVar
		 , uint8&amp; RetByteVar
		 , int32&amp; RetIntegerVar
		 , float&amp; RetFloatVar
		 , FName&amp; RetNameVar
		 , FString&amp; RetStringVar
		 , FText&amp; RetTextVar
		 , FVector&amp; RetVectorVar
		 , FTransform&amp; RetTransformVar
		 , UObject*&amp; RetObjectVar
		 , TSubclassOf&lt;UObject&gt;&amp; RetClassVar
	 ) ;
</code></pre>
<p>对应的自动生成的Thunk函数体示例：</p>
<pre><code class="language-c++">DECLARE_FUNCTION(execTestFunction) \
{ \
	P_GET_UBOOL(Z_Param_BoolVar); \
	P_GET_PROPERTY(UByteProperty, Z_Param_ByteVar); \
	P_GET_PROPERTY(UIntProperty, Z_Param_IntegerVar); \
	P_GET_PROPERTY(UFloatProperty, Z_Param_FloatVar); \
	P_GET_PROPERTY(UNameProperty, Z_Param_NameVar); \
	P_GET_PROPERTY(UStrProperty, Z_Param_StringVar); \
	P_GET_PROPERTY_REF(UTextProperty, Z_Param_Out_TextVar); \
	P_GET_STRUCT(FVector, Z_Param_VectorVar); \
	P_GET_STRUCT(FTransform, Z_Param_TransformVar); \
	P_GET_OBJECT(UObject, Z_Param_ObjectVar); \
	P_GET_OBJECT(UClass, Z_Param_ClassVar); \
	P_GET_UBOOL_REF(Z_Param_Out_RetBoolVar); \
	P_GET_PROPERTY_REF(UByteProperty, Z_Param_Out_RetByteVar); \
	P_GET_PROPERTY_REF(UIntProperty, Z_Param_Out_RetIntegerVar); \
	P_GET_PROPERTY_REF(UFloatProperty, Z_Param_Out_RetFloatVar); \
	P_GET_PROPERTY_REF(UNameProperty, Z_Param_Out_RetNameVar); \
	P_GET_PROPERTY_REF(UStrProperty, Z_Param_Out_RetStringVar); \
	P_GET_PROPERTY_REF(UTextProperty, Z_Param_Out_RetTextVar); \
	P_GET_STRUCT_REF(FVector, Z_Param_Out_RetVectorVar); \
	P_GET_STRUCT_REF(FTransform, Z_Param_Out_RetTransformVar); \
	P_GET_OBJECT_REF(UObject, Z_Param_Out_RetObjectVar); \
	P_GET_OBJECT_REF_NO_PTR(TSubclassOf&lt;UObject&gt;, Z_Param_Out_RetClassVar); \
	P_FINISH; \
	P_NATIVE_BEGIN; \
	UMiscAlgorithm::TestFunction(Z_Param_BoolVar, Z_Param_ByteVar, Z_Param_IntegerVar, Z_Param_FloatVar, Z_Param_NameVar, Z_Param_StringVar, Z_Param_Out_TextVar, Z_Param_VectorVar, Z_Param_TransformVar, Z_Param_ObjectVar, Z_Param_ClassVar, Z_Param_Out_RetBoolVar, Z_Param_Out_RetByteVar, Z_Param_Out_RetIntegerVar, Z_Param_Out_RetFloatVar, Z_Param_Out_RetNameVar, Z_Param_Out_RetStringVar, Z_Param_Out_RetTextVar, Z_Param_Out_RetVectorVar, Z_Param_Out_RetTransformVar, Z_Param_Out_RetObjectVar, Z_Param_Out_RetClassVar); \
	P_NATIVE_END; \
} \
</code></pre>
<h3 id="b获取泛型参数的代码的编写方法">b.<strong>获取泛型参数的代码的编写方法：</strong></h3>
<p>ue4 v4.25以上版本 UProperty已被FProperty替代，本质没变，只需稍作修改。以下代码为4.25之前版本。获取泛型参数需要同时获取该变量地址void<em>和变量属性UProperty</em>/ UArrayProperty* / UMapProperty* / USetProperty*，如下示例：</p>
<p><strong>获取泛型Single Variable</strong></p>
<pre><code class="language-c++">Stack.StepCompiledIn&lt;UStructProperty&gt;(NULL);
void* SrcPropertyAddr = Stack.MostRecentPropertyAddress;
UProperty* SrcProperty = Cast&lt;UProperty&gt;(Stack.MostRecentProperty);
</code></pre>
<p><strong>获取泛型Array Variable</strong></p>
<pre><code class="language-c++">  Stack.StepCompiledIn&lt;UArrayProperty&gt;(NULL);
  void* SrcArrayAddr = Stack.MostRecentPropertyAddress;
  UArrayProperty* SrcArrayProperty = Cast&lt;UArrayProperty&gt;(Stack.MostRecentProperty);
</code></pre>
<p><strong>获取泛型Map Variable</strong></p>
<pre><code class="language-c++">  Stack.MostRecentProperty = nullptr;
  Stack.StepCompiledIn&lt;UMapProperty&gt;(NULL);
  void* SrcMapAddr = Stack.MostRecentPropertyAddress;
  UMapProperty* SrcMapProperty = Cast&lt;UMapProperty&gt;(Stack.MostRecentProperty);
</code></pre>
<p><strong>获取泛型Set Variable</strong></p>
<pre><code class="language-c++">  Stack.MostRecentProperty = nullptr;
  Stack.StepCompiledIn&lt;USetProperty&gt;(NULL);
  void* SetAddr = Stack.MostRecentPropertyAddress;
  USetProperty* SetProperty = Cast&lt;USetProperty&gt;(Stack.MostRecentProperty);
</code></pre>
<h1 id="5-conclusion"><strong>5. Conclusion</strong></h1>
<p>以上内容讲述了泛型蓝图节点的三个组成部分的主要功能，以及带泛型参数蓝图节点的声明方法和自定义Thunk函数体的实现过程。为避免文章过长，在下一节 <strong>UE4 基于CustomThunk的泛型蓝图节点语法规范 (二)，</strong> 将分享几个自己编写的泛型蓝图节点**，**让大家对自定义泛型蓝图节点的第三部分-泛型函数（Generic）有加全面而清晰认识。</p>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://xusjtuer.github.io/post/ue4-post3_generic_get_set_object_property/" class="post-title gt-a-link">
                    UE4 泛型蓝图节点的实现及应用实例
                </a>
            </div>
        

        
            <span id="/post/" class="leancloud_visitors" data-flag-title="UE4 基于CustomThunk的泛型蓝图节点语法规范 (一)">
                <em class="post-meta-item-text">阅读量 </em>
                <i class="leancloud-visitors-count">0</i>
            </span>
        

        

        
            <script src='https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js'></script>

<style>
	div#vcomments{
		width:100%;
		max-width: 1000px;
		padding: 2.5%
	}
</style>


	<div id="vcomments"></div>

<script>
	new Valine({
		el: '#vcomments',
		appId: 'eDbdj40FUkgrqBO4v2ihwBBx-gzGzoHsz',
		appKey: 'i7tyyD1xatuPB35wS8NPJ4f9',
		avatar: '',
		pageSize: 5,
		recordIp: true,
		placeholder: 'Just Go Go',
		visitor: true,
	});
</script>

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">海阔凭鱼跃，天高任鸟飞</div>
    <div class="social-container">
        
            
                <a href="https://github.com/xusjtuer" target="_blank">
                    <i class="fab fa-github gt-c-content-color-first"></i>
                </a>
            
        
            
        
            
        
            
                <a href="https://www.zhihu.com/people/tong-nian-de-qin" target="_blank">
                    <i class="fab fa-zhihu gt-c-content-color-first"></i>
                </a>
            
        
            
        
            
        
    </div>
    <div class="footer-info">
        Powered by <a href="https://github.com/xusjtuer" target="_blank">xusjtuer</a>
    </div>
    <div>
        Theme by <a href="https://imhanjie.com/" target="_blank">imhanjie</a>, Powered by <a
                href="https://github.com/getgridea/gridea" target="_blank">Gridea | <a href="https://xusjtuer.github.io/atom.xml" target="_blank">RSS</a></a>
    </div>
</div>

<script>
  hljs.initHighlightingOnLoad()
</script>

    </div>
</div>
</body>
</html>
