{"posts":[{"title":"UE4 C++实现任意类型数组蓝图排序节点（Quick Sort）","content":"1. Overview 本教程旨在讲解在虚幻引擎(UE4) C++中实现蓝图(Blueprint)可调用的任意类型数组排序的蓝图节点。纯蓝图实现任意类型数组排序方法，请查看***第1期 在蓝图实现任意类型数组排序*。以下泛型数组排序节点Array_Sort基于快速排序算法（Quick Sort）原理，冒泡排序（Bubble Sort）版见知乎链接：第2期 UE4 C++实现任意类型数组蓝图排序节点。编者水平有限，如有错漏敬请谅解。 2. Quick Sort/Bubble Sort /蓝图宏排序比较 排序算法是开发过程中常用的一类算法，使用ue4进行开发不可避免的要用到排序算法。若仅使用ue4 c++进行内容开发，可以直接调用c++ stl中的排序算法，就可以实现数组排序。由于ue4 c++本身并没给蓝图系统(Blueprint System)提供任意类型数组排序的节点，因此当同时使用ue4 c++和Blueprint(BP)完成逻辑功能，如何在ue4 c++ 中实现一个任意类型数组排序蓝图节点，就成为一个值得深究的问题。 本文主要讲解ue4 c++实现任意类型数组排序的蓝图节点方法和原理，以及该节点在Blueprint中的使用方法。 5. Sort Approach 5.1 基于SortBy Function，实现泛型数组排序 .h文件，函数声明： /** Generic sort array by function using quick sort algorithm. * * @param Array Target array to sort * @param Object The owner of CompareBy function,(DefaultToSelf) * @param SortBy Function name of overloads operator &quot;&lt;&quot; function The signature of the comparison function should be equivalent to the following: bool cmp(const Type1 &amp;a, const Type2 &amp;b); return value should named &quot;ReturnValue&quot;(bool) */ UFUNCTION(BlueprintCallable, CustomThunk, meta = (DisplayName = &quot;Sort Array by Function&quot;, CompactNodeTitle = &quot;Sort&quot;, ArrayParm = &quot;Array&quot;, AutoCreateRefTerm = &quot;Array&quot;, DefaultToSelf = &quot;Object&quot;, AdvancedDisplay = &quot;Object&quot;), Category = &quot;Utilities|Array&quot;) static void Array_SortV1(const TArray&lt;int32&gt;&amp; Array, UObject* Object, FName SortBy); // generic quick sort array by function name static void GenericArray_SortByFunction(UObject* OwnerObject, UFunction* ComparedBy, void* TargetArray, UArrayProperty* ArrayProp); // Low --&gt; Starting index, High --&gt; Ending index static void QuickSortByFunction_Recursive(UObject* OwnerObject, UFunction* ComparedBy, UProperty* InnerProp, FScriptArrayHelper&amp; ArrayHelper, int32 Low, int32 High); // swapping items in place and partitioning the section of an array static int32 QuickSortByFunction_Partition(UObject* OwnerObject, UFunction* ComparedBy, UProperty* InnerProp, FScriptArrayHelper&amp; ArrayHelper, int32 Low, int32 High); // Check that the CompareBy function is appropriate static bool IsSuitableFunction(UFunction* ComparedBy, UArrayProperty* ArrayProp); .h文件，Array_SortV1函数的自定义CustomThunk函数体 // sort array by function name DECLARE_FUNCTION(execArray_SortV1) { Stack.MostRecentProperty = nullptr; Stack.StepCompiledIn&lt;UArrayProperty&gt;(NULL); void* ArrayAAddr = Stack.MostRecentPropertyAddress; UArrayProperty* ArrayProperty = Cast&lt;UArrayProperty&gt;(Stack.MostRecentProperty); if (!ArrayProperty) { Stack.bArrayContextFailed = true; return; } P_GET_OBJECT(UObject, OwnerObject); P_GET_PROPERTY(UNameProperty, SortBy); if (!OwnerObject) { return; } UFunction* const SortFunction = OwnerObject-&gt;FindFunction(SortBy); if ((!SortFunction || (SortFunction-&gt;NumParms != 3))) { return; } P_FINISH; P_NATIVE_BEGIN; GenericArray_SortByFunction(OwnerObject, SortFunction, ArrayAAddr, ArrayProperty); P_NATIVE_END; } .cpp文件，GenericArray_SortByFunction()函数体 void UGenericArrayLibrary::GenericArray_SortByFunction(UObject* OwnerObject, UFunction* ComparedBy, void* TargetArray, UArrayProperty* ArrayProp) { if (!ComparedBy || !OwnerObject || !TargetArray) { return; } else if (!IsSuitableFunction(ComparedBy, ArrayProp)) { return; } // Optimal UKismetArrayLibrary::GenericArray_Shuffle(TargetArray, ArrayProp); // Begin sort array FScriptArrayHelper ArrayHelper(ArrayProp, TargetArray); if (ArrayHelper.Num() &lt; 2) { return; } else { UProperty* InnerProp = ArrayProp-&gt;Inner; QuickSortByFunction_Recursive(OwnerObject, ComparedBy, InnerProp, ArrayHelper, 0, ArrayHelper.Num() - 1); } } 其中，快排算法优化： // Optimal UKismetArrayLibrary::GenericArray_Shuffle(TargetArray, ArrayProp); //cpp文件，快排递归循环 void UGenericArrayLibrary::QuickSortByFunction_Recursive(UObject* OwnerObject, UFunction* ComparedBy, UProperty* InnerProp, FScriptArrayHelper&amp; ArrayHelper, int32 Low, int32 High) { if (Low &lt; High) { int32 Pivot = QuickSortByFunction_Partition(OwnerObject, ComparedBy, InnerProp, ArrayHelper, Low, High); QuickSortByFunction_Recursive(OwnerObject, ComparedBy, InnerProp, ArrayHelper, Low, Pivot - 1); QuickSortByFunction_Recursive(OwnerObject, ComparedBy, InnerProp, ArrayHelper, Pivot + 1, High); } } //.cpp文件，快排拆分 int32 UGenericArrayLibrary::QuickSortByFunction_Partition(UObject* OwnerObject, UFunction* ComparedBy, UProperty* InnerProp, FScriptArrayHelper&amp; ArrayHelper, int32 Low, int32 High) { const int32 PropertySize = InnerProp-&gt;ElementSize * InnerProp-&gt;ArrayDim; UBoolProperty* ReturnProp = Cast&lt;UBoolProperty&gt;(ComparedBy-&gt;GetReturnProperty()); // CompareBy function parameters address, 2 input parameter(array item) and 1 return parameter (bool) uint8* FuncParamsAddr = (uint8*)FMemory::Malloc(ComparedBy-&gt;ParmsSize); /// note:ParamsSize = PropertySize* 2 +1 FMemory::Memzero(FuncParamsAddr, ComparedBy-&gt;ParmsSize); /** Based on quick sort of stl */ InnerProp-&gt;CopyCompleteValueFromScriptVM(FuncParamsAddr, ArrayHelper.GetRawPtr(High)); //Params1: LastSmallElem = Array[High] int32 i = Low - 1; for (int32 j = Low; j &lt; High; j++) { InnerProp-&gt;CopyCompleteValueFromScriptVM(FuncParamsAddr + PropertySize, ArrayHelper.GetRawPtr(j)); // Param2: Array[i] OwnerObject-&gt;ProcessEvent(ComparedBy, FuncParamsAddr); if (ReturnProp &amp;&amp; ReturnProp-&gt;GetPropertyValue(FuncParamsAddr + PropertySize * 2)) { i++; ArrayHelper.SwapValues(i, j); } } ArrayHelper.SwapValues(i + 1, High); // release memory FMemory::Free(FuncParamsAddr); return i + 1; } //.cpp文件，判断用于比较数组元素大小的蓝图函数是否合适 bool UGenericArrayLibrary::IsSuitableFunction(UFunction* ComparedBy, UArrayProperty* ArrayProp) { // check CompareBy function's parameter number if ((!ComparedBy || (ComparedBy-&gt;NumParms != 3))) { UE_LOG(LogTemp, Warning, TEXT(&quot;IsSuitableFunction -&gt; CompareBy function should only have 3 parameters !&quot;)); return false; } //Get return property of CompareBy function. UBoolProperty* ReturnProp = Cast&lt;UBoolProperty&gt;(ComparedBy-&gt;GetReturnProperty()); if (!ReturnProp) { /// The return Property of max function must be bool and named &quot;ReturnValue&quot; UE_LOG(LogTemp, Warning, TEXT(&quot;IsSuitableFunction -&gt; Return value of CompareBy function should be bool type, and named ReturnValue.&quot;)); return false; } // Get all parameters of CompareBy function TArray&lt;UProperty*&gt; ParamterList; for (TFieldIterator&lt;UProperty&gt; It(ComparedBy); It; ++It) { UProperty* FuncParameter = *It; ParamterList.Emplace(FuncParameter); } // Make sure the first/second input parameters of Compare function is same to array inner if (!ParamterList[0]-&gt;SameType(ArrayProp-&gt;Inner) || !ParamterList[1]-&gt;SameType(ArrayProp-&gt;Inner)) { /// The property of 1st input parameter of max function must be same as array member UE_LOG(LogTemp, Warning, TEXT(&quot;IsSuitableFunction -&gt; The parameters type of CompareBy should be same to array member.&quot;)); return false; } return true; } 5.2 基于SortBy Property，实现泛型数组排序 6. Conclusion 本文主要介绍了二种 ue4 c++实现任意类型数组排序蓝图节点的方法，用于满足日常开发的蓝图排序需求。由于二者均为冒泡排序原理，算法效率一般低于的stl排序算法。 进阶版：基于stl排序算法的任意类型数组排序节点的实现，待完成。 ","link":"https://xusjtuer.github.io/post/ue4-cshi-xian-ren-yi-lei-xing-shu-zu-lan-tu-pai-xu-jie-dian/"},{"title":"UE4 蓝图实现任意类型数组排序","content":"蓝图实现任意类型数组排序 Implementation of wildcard array sort in blueprint 1. Overview ​本教程旨在讲解在虚幻引擎(UE4)蓝图（blueprint）中实现任意类型的数组排序，也就是实现泛型数组排序，在UE4的蓝图系统中用Wildcard（通配符）表示泛型。本教程基于选择排序（Selection Sort）和冒泡排序（Bubble Sort）原理，利用蓝图宏，实现了对任意类型数组（Generic TArray）排序的蓝图宏节点。 2. Required Knowledge ​ (1) 基本熟悉ue4，了解蓝图宏库（Blueprint Macro Library）的创建方法； ​ (2) Selection Sort 和 Bubble Sort 排序原理； 3. Why ​UE4的蓝图系统并未内置数组排序（Array Sort）的蓝图节点，但是对数组进行排序可以说是开发中无可避免的问题。虽然在使用C++进行开发时，可以轻易调用C++ STL的排序算法，并使用宏UFUNCTION(BlueprintCallable)，将其暴露给蓝图；但是这种处理方式，对于随时新增加的类型（UStruct/UObject派生类），每一种类型的数据都要自定义一个C++版排序函数。既耗费了不必要代码修改和编译时间，又增加了代码冗余。 如果可以用一个节点来完成对任意类型数组排序，显然有极大的好处。 此外，虽然可以在UE4 C++中使用Wildcard 变量来实现数组排序，但是其实现过程较为复杂、繁琐，门框过高。还可能存在适用性的问题，可能无法同时对int，float，struct，object及其派生类（Actor）等都适用。 4. Sort Approach （1）创建蓝图宏库，鼠标右键-&gt;Blueprints-&gt;Blueprint Macro Library -&gt;All Classes-&gt;Object，以UObject作为蓝图宏库的基类。 （2）My Blueprint窗口，Add New创建二个宏Select Sort、Bubble Sort； （3）选择排序（Select Sort） Description： 选择排序(详情请查阅选择排序方法) bGreater=( Array[min] &gt;Array[i] ) ? true : false; 将Array[min]与Array[i]成员的大小比较结果连接上bGreater(pin) 内部循环根据bGreater(bool)值判断是否交换Array[min]与Array[i]成员位置 排序结束，返回有序数组 图1. 选择排序细节面板，（Array Pin 勾选Pass-by-Reference，以引用方式传递数据）； 选择排序（Selection Sort）蓝图宏实现方法 图2. 选择排序蓝图宏； （4）冒泡排序（Bubble Sort） ​ Description：冒泡排序(详情请查阅冒泡排序方法) ​ bGreater=( Array[j] &gt;Array[j+1] ) ? true : false; ​ 将Array[j]与Array[j+1]的大小比较结果连接上bGreater(pin) ​ 内部循环根据bGreater(bool)值判断是否交换Array[j]与Array[j+1]成员位置 ​ 排序结束，返回有序数组 图3. 冒泡排序细节面板，（Array Pin 勾选Pass-by-Reference，以引用方式传递数据）； 冒泡排序（Bubble Sort）蓝图宏实现方法! 图4. 冒泡排序蓝图宏； 5. Usage （1）以上第4步完成，即可任意蓝图中，context menu中输入sort关键词即可查找二个节点； 图5. 从蓝图中查找Bubble Sort/Selection Sort节点； （2）任意类型数组引脚（pin）连接示例，下图以Bubble Sort节点为例，并随意选取Actor、Struct、Float、Int类型数组； 图6. 不同类型数组排序示例； （3）排序节点连接方式示例，（数组元素类型必须包含可排序得变量，如float/int类型变量）； 图7. Item数组排序示例，Score变量为本例排序指定关键字； （4）排序方向，升序/降序示例 图8. a. 返回升序数组； 图9. b. 返回降序数组； （5）二个以上排序变量蓝图引脚连接示例，该类情形最好自定义一个比较函数（Pure函数），如下图所示 图10. 蓝图引脚连接示例； 图11. 二个排序排序变量，大小比较方法示例，并该函数设置成Pure； 6. Shortage 由于冒泡排序和选择排序本身就属于低效的排序算法，此外相较于c++，蓝图执行效率差得多，因此以上二个蓝图泛型排序节点应当只用于长度较小的数组排序（length&lt;100）。若数组长度超过一定值时，会产生明显的卡顿，甚至会直接停止运行，并显示以下错误提示。 LogScript: Warning: Runaway loop detected (over 1,000,000 iterations) - see log for stack trace BP_HttpActotr_C /Game/Maps/UEDPIE_0_BeginMap.BeginMap:PersistentLevel.BP_HttpActotr_2 Function /Game/Blueprints/BP_HttpActotr.BP_HttpActotr_C:ExecuteUbergraph_BP_HttpActotr:0250 PIE: Error: Infinite loop detected. Blueprint: BP_HttpActotr Function: Branch Call Stack: Show 7. Conclusion 本文主要介绍使用UE4 蓝图宏实现任意类型数组排序的蓝图节点，可以在数组长度较小的情形下，对数组进行排序。由于排序算法和蓝图节点执行的效率均比较低，因此不建议在数组长度大的情形，使用以上节点进行排序。 原创文章，未经允许，禁止转载 ","link":"https://xusjtuer.github.io/post/ue4-dong-tai-du-xie-datatable-shu-ju-biao/"}]}