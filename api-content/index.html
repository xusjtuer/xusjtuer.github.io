{"posts":[{"title":"test comment","content":"1 ","link":"https://xusjtuer.github.io/post/test-comment/"},{"title":"UE4 异步蓝图节点设计与实现","content":"摘要：函数的异步调用是编程过程中一种常见的调用方式，虽然虚幻引擎拥有强大的蓝图系统，但是在处理异步调用时，现有的蓝图节点却常常束手无策。本教程旨讲解在ue4中设计并实现异步蓝图节点的全流程，以实现具有计时、可取消延迟Delay、同时处理N个对象的异步调用等多个功能的异步蓝图节点SetTimer为例，逐一解析异蓝图节点从需求、设计、实现、应用各个过程。 关键字：虚幻引擎；蓝图；异步；定时器 Design and Implementation of Asynchronous Blueprint Node Abstract：Asynchronous calling of functions is a common calling way in the programming process. Although Unreal Engine has a powerful blueprint system, the existing blueprint nodes are often at a loss for handling asynchronous call processes. This tutorial aims to explain the whole process of designing and implementing asynchronous blueprint nodes in ue4.Taking the custom asynchronous blueprint node SetTimer, which has the functions of timing, delay, and asynchronous call of N objects at the same time, as an example. Analyze each process of asynchronous blueprint nodes from requirements, design, implementation, and application one by one. Key words: Unreal Engine; Blueprint; Async; Timer 1. Introduction 使用ue4开发时，常常会遇到异步调用情形；在上一个函数A执行结束，才触发下一个函数B，且函数A是一个多帧执行的持续过程，比如移动到目标点。若函数A在执行时被中止，则函数B不执行，换言之函数B应该是可被取消的延迟调用。对于单个对象的上述情形，使用蓝图系统中Set Timer By Event节点不难解决；若是同时处理N个不同类型对象的异步调用，则内置的蓝图节点难以应对。 利用ue4蓝图系统中内置节点完成简单异步调用包含以下方式： Delay：等待一定时间，再执行下一个函数；缺点： Delay未结束前，Delay之后的逻辑被阻塞；且无法取消Delay后面的事件； Timeline：Timeline功能较为完善，包含Play、Stop、Reverse等功能；缺点：只能在Actor及其派生类中使用，无法在Object、UMG等其他类蓝图中使用；无法动态添加； SetTimerByEvent / SetTimerByFunctionName：支持绑定事件，支持Pause、Unpause、Clear，计时等功能；缺点：无法同时处理多个对象的异步过程。 Tick：Tick时，执行多帧持续性的逻辑；满足结束条件后，调用回调事件逻辑；缺点：需要独立封装。 利用ue4 c++中实现异步蓝图函数包含以下方式： 使用UFunction宏中的Latent关键字，标识该蓝图函数为Latent function(潜伏事件)，在函数体内创建一个FPendingLatentAction派生类的实例并初始化，异步操作的主要过程均在派生类实例上完成。内置蓝图节点的Delay、MoveComponentTo等均采用这类方法。 继承UBlueprintAsyncActionBase类，重写派生类的函数；内置蓝图节点DownloadImage节点属于此类。 Tick和蓝图Tick一样，需要单独封装。 ue4的异步与非异步的蓝图节点在外观上有一个明显的不同，就是异步蓝图节点右上角存时钟标记；使用时，异步蓝图节点可以在EventGraph/Macros中使用，但是无法在蓝图函数（FunctionGraph）中使用。由于异步节点被调用时，可能同时存在多个任务，所以与一般的蓝图节点只有一对输入输出执行流引脚不同，异步节点可能拥有多个执行流引脚；一对执行流引脚用于继续执行主逻辑，其他执行流引脚用于处理异步过程结束后的返回结果，这样而不至于阻塞程序主要逻辑的执行。 图1. 异步和非异步蓝图节点； 2. Design 由上一小节不难得出结论：[需求] 若要同时处理N个对象的异步调用，引擎内置的蓝图节点是难以满足需求的，因此设计并实现一个具有这样功能的蓝图节点是十分必要的。Set Timer By Event支持Pause、Unpause、Clear等功能，也可以等效地被封装成一个可取消的Delay节点；但是由于SetTimerByEevent节点的Delegate是一个无参数的委托，因此在处理N个对象的时候，无法确定是哪一个对象完成了Delay过程。[设计] 假设我们把Set Timer By Event节点的左侧输入引脚Event，移到节点右侧，变成一个输出执行流引脚Completed；并且在执行Completed引脚后的函数时，可以同时返回TimerHandle，那么就可以根据TimerHandle取得与之对应的Object，然后调用该Object的函数，完成同时处理N个对象的异步调用**。**在经过以上调整，新SetTimer节点的引脚应该是如下结构。 图2. SetTimer节点的引脚； 在同时处理N个对象的异步调用时，每个对象的异步过程执行时间和间隔都可以是独立的，使用以下蓝图节点处理N个对象异步过程。 同时处理N个对象的异步调用简易方案； 3. Source code **[实现]**源代码如下所示，在去除注释和空行，余下不过70+行，其中特别需要注意的是GC过程。首先贴出源代码，随后解释代码中各个部分的作用。 //.h 文件 // Fill out your copyright notice in the Description page of Project Settings. #pragma once #include &quot;CoreMinimal.h&quot; #include &quot;Kismet/BlueprintAsyncActionBase.h&quot; #include &quot;Engine/EngineTypes.h&quot; #include &quot;Async_SetTimer.generated.h&quot; // Declare General Log Category, header file .h DECLARE_LOG_CATEGORY_EXTERN(LogAsyncAction, Log, All); /** * */ UCLASS(meta = (HideThen = true)) class ASYNCSYSTEM_API UAsync_SetTimer : public UBlueprintAsyncActionBase { // Delcear delegate for finished delay DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FTimerHandleDelegate, FTimerHandle, TimerHandle); GENERATED_BODY() public: UAsync_SetTimer(); ~UAsync_SetTimer(); public: /** * Set a timer to execute Completed delegate. Setting an existing timer will reset that timer with updated parameters. * @param WorldContextObject The world context. * @param Time How long to wait before executing the delegate, in seconds. Setting a timer to &lt;= 0 seconds will clear it if it is set. * @param bLooping True to keep executing the delegate every Time seconds, false to execute delegate only once. * @param InitialStartDelay Initial delay passed to the timer manager, in seconds. * @param InitialStartDelayVariance Use this to add some variance to when the timer starts in lieu of doing a random range on the InitialStartDelay input, in seconds. * @return The timer handle to pass to other timer functions to manipulate this timer. */ UFUNCTION(BlueprintCallable, meta = (BlueprintInternalUseOnly = &quot;true&quot;, WorldContext = &quot;WorldContextObject&quot;, DisplayName = &quot;Set Timer&quot;, ScriptName = &quot;SetTimerDelegate&quot;, AdvancedDisplay = &quot;InitialStartDelay, InitialStartDelayVariance&quot;), Category = &quot;Utilities|Time&quot;) static UAsync_SetTimer* SetTimer(const UObject* WorldContextObject, float Time, bool bLooping, float InitialStartDelay = 0.f, float InitialStartDelayVariance = 0.f); public: // Generate exec out pin /** Generate Exec Outpin, named Then */ UPROPERTY(BlueprintAssignable) FTimerHandleDelegate Then; /** Generate Exec Outpin, named Completed */ UPROPERTY(BlueprintAssignable) FTimerHandleDelegate Completed; private: // UBlueprintAsyncActionBase interface virtual void Activate() override; //~ END UBlueprintAsyncActionBase interface /** UFunction for Delegate.BindUFunction; */ UFUNCTION() void CompletedEvent(); /** Based on UKismetSystemLibrary::K2_SetTimerDelegate() */ FTimerHandle SetTimerDelegate(FTimerDynamicDelegate Delegate, float Time, bool bLooping, float InitialStartDelay = 0.f, float InitialStartDelayVariance = 0.f); /** Action for garbage class instance */ void PreGarbageCollect(); private: const UObject* WorldContextObject; FTimerHandle TimerHandle; UWorld* World; }; //.cpp 文件 // Fill out your copyright notice in the Description page of Project Settings. #include &quot;Async_SetTimer.h&quot; #include &quot;Kismet/KismetSystemLibrary.h&quot; //Declare General Log Category, source file .cpp DEFINE_LOG_CATEGORY(LogAsyncAction); UAsync_SetTimer::UAsync_SetTimer() { WorldContextObject = nullptr; //if (HasAnyFlags(RF_ClassDefaultObject) == false) //{ // AddToRoot(); //} // Helper message to track object instance UE_LOG(LogAsyncAction, Log, TEXT(&quot;UAsync_SetTimer::UAsync_SetTimer(): Async_SetTimer object [%s] is being created.&quot;), *this-&gt;GetName()); } UAsync_SetTimer::~UAsync_SetTimer() { // Helper message to track object instance UE_LOG(LogAsyncAction, Log, TEXT(&quot;UAsync_SetTimer::~UAsync_SetTimer(): Async_SetTimer object is being deleted.&quot;)); } UAsync_SetTimer* UAsync_SetTimer::SetTimer(const UObject* WorldContextObject, float Time, bool bLooping, float InitialStartDelay /*= 0.f*/, float InitialStartDelayVariance /*= 0.f*/) { if (!WorldContextObject) { FFrame::KismetExecutionMessage(TEXT(&quot;Invalid WorldContextObject. Cannot execute Set Timer.&quot;), ELogVerbosity::Error); return nullptr; } /** Based on UKismetSystemLibrary::K2_SetTimer() */ InitialStartDelay += FMath::RandRange(-InitialStartDelayVariance, InitialStartDelayVariance); if (Time &lt;= 0.f || ((Time + InitialStartDelay) - InitialStartDelayVariance) &lt; 0.f) { FFrame::KismetExecutionMessage(TEXT(&quot;SetTimer passed a negative or zero time. The associated timer may fail to fire! If using InitialStartDelayVariance, be sure it is smaller than (Time + InitialStartDelay).&quot;), ELogVerbosity::Warning); return nullptr; } UAsync_SetTimer* AsyncNode = NewObject&lt;UAsync_SetTimer&gt;(); AsyncNode-&gt;WorldContextObject = WorldContextObject; FTimerDynamicDelegate Delegate; Delegate.BindUFunction(AsyncNode, FName(&quot;CompletedEvent&quot;)); AsyncNode-&gt;TimerHandle = AsyncNode-&gt;SetTimerDelegate(Delegate, Time, bLooping, InitialStartDelay, InitialStartDelayVariance); // Call to globally register this object with a game instance, it will not be destroyed until SetReadyToDestroy is called AsyncNode-&gt;RegisterWithGameInstance((UObject*)WorldContextObject); FCoreUObjectDelegates::GetPreGarbageCollectDelegate().AddUObject(AsyncNode, &amp;UAsync_SetTimer::PreGarbageCollect); return AsyncNode; } /** Based on UKismetSystemLibrary::K2_SetTimerDelegate() */ FTimerHandle UAsync_SetTimer::SetTimerDelegate(FTimerDynamicDelegate Delegate, float Time, bool bLooping, float InitialStartDelay /*= 0.f*/, float InitialStartDelayVariance /*= 0.f*/) { FTimerHandle Handle; if (Delegate.IsBound()) { World = GEngine-&gt;GetWorldFromContextObject(WorldContextObject, EGetWorldErrorMode::ReturnNull); if (World) { InitialStartDelay += FMath::RandRange(-InitialStartDelayVariance, InitialStartDelayVariance); if (Time &lt;= 0.f || ((Time + InitialStartDelay) - InitialStartDelayVariance) &lt; 0.f) { FFrame::KismetExecutionMessage(TEXT(&quot;SetTimer passed a negative or zero time. The associated timer may fail to fire! If using InitialStartDelayVariance, be sure it is smaller than (Time + InitialStartDelay).&quot;), ELogVerbosity::Warning); } FTimerManager&amp; TimerManager = World-&gt;GetTimerManager(); Handle = TimerManager.K2_FindDynamicTimerHandle(Delegate); TimerManager.SetTimer(Handle, Delegate, Time, bLooping, (Time + InitialStartDelay)); } } else { UE_LOG(LogBlueprintUserMessages, Warning, TEXT(&quot;SetTimer passed a bad function (%s) or object (%s)&quot;), *Delegate.GetFunctionName().ToString(), *GetNameSafe(Delegate.GetUObject())); } return Handle; } void UAsync_SetTimer::PreGarbageCollect() { if (World) { FTimerManager&amp; TimerManager = World-&gt;GetTimerManager(); if (!TimerManager.TimerExists(TimerHandle)) { SetReadyToDestroy(); } } } void UAsync_SetTimer::Activate() { if (!WorldContextObject) { FFrame::KismetExecutionMessage(TEXT(&quot;Invalid WorldContextObject. Cannot execute Set Timer.&quot;), ELogVerbosity::Error); return; } // call Then delegate binding event Then.Broadcast(TimerHandle); } void UAsync_SetTimer::CompletedEvent() { Completed.Broadcast(TimerHandle); } 声明Delegate：声明了包含一个参数的委托Delegate，参数类型为FTimerHandle，名称TimerHandle。Delegate的参数将会出现在异步蓝图节点上。若仍不了解委托的声明方法，见官方文档：委托 在C++对象上引用和执行成员函数的数据类型。 // Delcear delegate DECLARE_DYNAMIC_MULTICAST_DELEGATE_OneParam(FTimerHandleDelegate, FTimerHandle, TimerHandle); 构造和析构函数：二个输出Log用于观察该对象是创建和销毁的时刻。 UAsync_SetTimer::UAsync_SetTimer() { WorldContextObject = nullptr; //if (HasAnyFlags(RF_ClassDefaultObject) == false) //{ // AddToRoot(); //} // Helper message to track object instance UE_LOG(LogAsyncAction, Log, TEXT(&quot;UAsync_SetTimer::UAsync_SetTimer(): Async_SetTimer object [%s] is being created.&quot;), *this-&gt;GetName()); } UAsync_SetTimer::~UAsync_SetTimer() { // Helper message to track object instance UE_LOG(LogAsyncAction, Log, TEXT(&quot;UAsync_SetTimer::~UAsync_SetTimer(): Async_SetTimer object is being deleted.&quot;)); } 声明Exec Pin**：**这一部分声明委托变量的个数将会决定此后异步蓝图节点执行流引脚的个数，以下声明将增加2个执行流。由于默认的执行流then输出引脚执行时并不能返回参数，在本例中几乎无任何作用，故使用UCLASS(meta =(HideThen =true))宏隐藏了默认的then执行流。如下图所示，若不使用该说明符将存在3个输出执行流引脚。 public: // Generate exec out pin /** Generate Exec Outpin, named Then */ UPROPERTY(BlueprintAssignable) FTimerHandleDelegate Then; /** Generate Exec Outpin, named Completed */ UPROPERTY(BlueprintAssignable) FTimerHandleDelegate Completed; 图3. 注意观察三个输出执行流引脚的提示tooltip； 声明异步节点**：**此处声明了该蓝图节点，BlueprintInternalUseOnly =&quot;true&quot;，隐藏自动生成的非异步蓝图节点，没有这个说明符将蓝图中看到二个同名节点。此函数的返回值必须是该派生类类型的指针，该返回值参数不会出现在蓝图节中，函数体主要用于输入参数检验、创建派生类对象以及赋值。 UFUNCTION(BlueprintCallable, meta = (BlueprintInternalUseOnly = &quot;true&quot;, WorldContext = &quot;WorldContextObject&quot;, DisplayName = &quot;Set Timer&quot;, ScriptName = &quot;SetTimerDelegate&quot;, AdvancedDisplay = &quot;InitialStartDelay, InitialStartDelayVariance&quot;), Category = &quot;Utilities|Time&quot;) static UAsync_SetTimer* SetTimer(const UObject* WorldContextObject, float Time, bool 图4. 声明函数时，不使用BlueprintInternalUseOnly =\"true\";说明符； Activate()函数：基类UBlueprintAsyncActionBase的接口，在函数体内部触发委托绑定的事件。 void UAsync_SetTimer::Activate() { if (!WorldContextObject) { FFrame::KismetExecutionMessage(TEXT(&quot;Invalid WorldContextObject. Cannot execute Set Timer.&quot;), ELogVerbosity::Error); return; } // call Then delegate binding event Then.Broadcast(TimerHandle); } GC管理（特别重要**）**：UBlueprintAsyncActionBase是UObject派生类，若不进行对象管理，则会自动被回收； 生成后，调用RegisterWithGameInstance()，防止自动回收 // Call to globally register this object with a game instance, it will not be destroyed until SetReadyToDestroy is called AsyncNode-&gt;RegisterWithGameInstance((UObject*)WorldContextObject); 结束时，调用Clear and Invalidate Timer by Handle节点后，该实例对象的TimerHandle被重置。UAsync_SetTimer::PreGarbageCollect()在系统每次进行GC前时被触发，检查UAsync_SetTimer实例的TimerHandle是否有效；如无效，则调用SetReadyToDestroy()，并在GC时，回收该实例对象。 void UAsync_SetTimer::PreGarbageCollect() { if (World) { FTimerManager&amp; TimerManager = World-&gt;GetTimerManager(); if (!TimerManager.TimerExists(TimerHandle)) { SetReadyToDestroy(); } } } 4. Usage 上述代码编译成功后，可在蓝图图表中找到SetTimer节点，下面列举异步节点SetTimer的3种功能：[应用] (1) 用作计时器，和内置的SetTimerByEvent相比，无需新定义一个函数；下面蓝图示例可用于计算二次调用间隔的时间。 SetTimer用作计时器； (2) 等效于一个非阻塞、可随时取消的Delay节点；Then引脚可以继续执行主逻辑，TimerHandle用来控制Completed引脚后连接函数的暂停、取消暂停、清空等操作。 SetTimer用作可取消的Delay； (3) 同时处理N个对象的异步调用；简单测试执行异步节点SetTimer消耗，下面蓝图代码随机生成100个StaticMeshActor，以不同的时间间隔让Actor自转，观察fps(Cmd: Stat UnitGraph, Game Frame曲线(Cmd: Stat UnitGraph)等参数几乎没明显变化，表明该节点耗损很小 。(提示：先要关闭测试StaticMeshActor的模拟物理，碰撞，Shadow等与SetTimer测试无关的属性) SetTimer 同时处理N个对象的异步调用； 5. Conclusion 本文以实现异步节点SetTimer为例，着重介绍使用UBlueprintAsyncActionBase派生类实现异步蓝图节点的全流程，其中特别需要注意的GC过程。扩展：(1)该SetTimer节点还可以进一步扩展，限制Completed引脚执行的次数；(2)UBlueprintAsyncActionBase派生类，如果同时继承FTickableGameObject就可以使输出执行流Tickable。 ","link":"https://xusjtuer.github.io/post/ue4-post8_async_bp_node_set_timer/"},{"title":"UE4 源代码改写过程和应用实例","content":"1. Overview 本教程以自定义函数GetTableAsJsonString()实现过程为例，旨在讲解如何将UE4源码中的部分源代码改写为自定义函数代码，同时也是为了补充上一期（第6期 UE4 动态读写DataTable数据表）的缺漏。 2. Introduction 虽然虚幻引擎功能强大，但也并非想要的功能都有。某些情况下，虽然在虚幻引擎源代码中已经存在你想要的功能，但是这些函数代码无法直接调用，常常也会遇到源代码中部分功能被WITH_EDITOR宏包裹，以至于这些函数无法在打包后调用。所以常常需要修改(改写)引擎源代码，它不仅可以弥补引擎内置功能的不足，而且相较于自己编写同样功能的代码的过程，耗时耗力、产生更多隐藏bug等问题；直接改写源代码工作量小，出错率相对低。修改引擎源代码，同时也是一种编程水平的体现，反映个人对源代码的理解程度。 上一期讲述了动态读写UE4 DataTable数据表的实现方法，其中GetTableAsCSVString()就是仿照源代码UDataTable::GetTableAsString()函数，可以轻而易举的实现该函数。但是上一期内容还缺失了一个蓝图函数GetTableAsJsonString()，完成将DataTable导出成Json字符串功能。GetTableAsJsonFile()只需要在获得DataTable相应的JsonString后，将其保存为Json文件即可。本期内容以实现自定义蓝图函数GetTableAsJsonString()为例，讲解如何将ue4引擎源代码中的功能化为己用。 #if WITH_EDITOR ENGINE_API virtual void CleanBeforeStructChange(); ENGINE_API virtual void RestoreAfterStructChange(); /** Output entire contents of table as a string */ ENGINE_API FString GetTableAsString(const EDataTableExportFlags InDTExportFlags = EDataTableExportFlags::None) const; /** Output entire contents of table as CSV */ ENGINE_API FString GetTableAsCSV(const EDataTableExportFlags InDTExportFlags = EDataTableExportFlags::None) const; /** Output entire contents of table as JSON */ ENGINE_API FString GetTableAsJSON(const EDataTableExportFlags InDTExportFlags = EDataTableExportFlags::None) const; /** Output entire contents of table as JSON */ ENGINE_API bool WriteTableAsJSON(const TSharedRef&lt; TJsonWriter&lt;TCHAR, TPrettyJsonPrintPolicy&lt;TCHAR&gt; &gt; &gt;&amp; JsonWriter, const EDataTableExportFlags InDTExportFlags = EDataTableExportFlags::None) const; /** Output entire contents of table as a JSON Object*/ ENGINE_API bool WriteTableAsJSONObject(const TSharedRef&lt; TJsonWriter&lt;TCHAR, TPrettyJsonPrintPolicy&lt;TCHAR&gt; &gt; &gt;&amp; JsonWriter, const EDataTableExportFlags InDTExportFlags = EDataTableExportFlags::None) const; /** Output the fields from a particular row (use RowMap to get RowData) to an existing JsonWriter */ ENGINE_API bool WriteRowAsJSON(const TSharedRef&lt; TJsonWriter&lt;TCHAR, TPrettyJsonPrintPolicy&lt;TCHAR&gt; &gt; &gt;&amp; JsonWriter, const void* RowData, const EDataTableExportFlags InDTExportFlags = EDataTableExportFlags::None) const; /** Copies all the import options from another table, this does not copy row dawta */ ENGINE_API bool CopyImportOptions(UDataTable* SourceTable); #endif UDataTable部分源代码； 首先，如上图所示，在UE4源代码UDataTable类中包含了GetTableAsJSON()函数，已经可以将DataTable数据表导出成Json字符串，但是该函数被WITH_EDITOR宏包裹着，并不能在项目打包之后使用。 FString UDataTable::GetTableAsJSON(const EDataTableExportFlags InDTExportFlags) const { FString Result; if (!FDataTableExporterJSON(InDTExportFlags, Result).WriteTable(*this)) { Result = TEXT(&quot;Missing RowStruct!\\n&quot;); } return Result; } UDataTable类的成员函数GetTableAsJSON()函数体； 继续查看UDataTable::GetTableAsJSON()函数体，可以看出，在构造FDataTableExporterJSON类的对象之后，调用FDataTableExporterJSON类的成员函数WriteTable()，从而获得DataTable导出的Json字符串； #if WITH_EDITOR class FDataTableExporterJSON { public: typedef TJsonWriter&lt;TCHAR, TPrettyJsonPrintPolicy&lt;TCHAR&gt;&gt; FDataTableJsonWriter; FDataTableExporterJSON(const EDataTableExportFlags InDTExportFlags, FString&amp; OutExportText); FDataTableExporterJSON(const EDataTableExportFlags InDTExportFlags, TSharedRef&lt;FDataTableJsonWriter&gt; InJsonWriter); ~FDataTableExporterJSON(); /** Writes the data table out as an array of objects */ bool WriteTable(const UDataTable&amp; InDataTable); /** Writes the data table out as a named object with each row being a sub value on that object */ bool WriteTableAsObject(const UDataTable&amp; InDataTable); /** Writes out a single row */ bool WriteRow(const UScriptStruct* InRowStruct, const void* InRowData, const FString* FieldToSkip = nullptr); /** Writes the contents of a single row */ bool WriteStruct(const UScriptStruct* InStruct, const void* InStructData, const FString* FieldToSkip = nullptr); private: bool WriteStructEntry(const void* InRowData, const UProperty* InProperty, const void* InPropertyData); bool WriteContainerEntry(const UProperty* InProperty, const void* InPropertyData, const FString* InIdentifier = nullptr); EDataTableExportFlags DTExportFlags; TSharedRef&lt;FDataTableJsonWriter&gt; JsonWriter; bool bJsonWriterNeedsClose; }; #endif // WITH_EDITOR FDataTableExporterJSON类； 进一步查看FDataTableExporterJSON类，该类所有代码也同样被WITH_EDITOR宏包裹着，从而可以得出结论，并不能简单的UDataTable::GetTableAsJSON()函数体代码放在WITH_EDITOR宏外调用，而是应该改写源代码中FDataTableExporterJSON类的成员函数WriteTable()。 3. Source Code 以下为改写后的源代码 .h文件，如下所示 // Fill out your copyright notice in the Description page of Project Settings. #pragma once #include &quot;CoreMinimal.h&quot; #include &quot;Kismet/BlueprintFunctionLibrary.h&quot; #include &quot;DataTableUtils.h&quot; // enum class EDataTableExportFlags : uint8 #include &quot;PrettyJsonPrintPolicy.h&quot; // TPrettyJsonPrintPolicy&lt;TCHAR&gt; #include &quot;DataTableLibrary.generated.h&quot; // Forward declarations class UDataTable; /** Based on FDataTableExporterJSON::FDataTableJsonWriter */ typedef TJsonWriter&lt;TCHAR, TPrettyJsonPrintPolicy&lt;TCHAR&gt;&gt; FDataTableJsonWriter; UCLASS() class FILESHELPER_API UDataTableLibrary : public UBlueprintFunctionLibrary { GENERATED_BODY() public:// /** Output entire contents of table as JSON string */ UFUNCTION(BlueprintCallable, DisplayName = &quot;Get Table As JSON String&quot;, Category = &quot;DataTable&quot;) static void GetDataTableAsJSONString(UDataTable* DataTable, FString&amp; JSONString); public: // Based on FDataTableExporterJSON /** Writes the data table out as an array of objects */ static bool WriteTable(TSharedRef&lt;FDataTableJsonWriter&gt; JsonWriter, const UDataTable&amp; InDataTable); /** Writes out a single row */ static bool WriteRow(TSharedRef&lt;FDataTableJsonWriter&gt; JsonWriter, const UScriptStruct* InRowStruct, const void* InRowData, const FString* FieldToSkip = nullptr); /** Writes the contents of a single row */ static bool WriteStruct(TSharedRef&lt;FDataTableJsonWriter&gt; JsonWriter, const UScriptStruct* InStruct, const void* InStructData, const FString* FieldToSkip = nullptr, const EDataTableExportFlags DTExportFlags = EDataTableExportFlags::None); /** Writes the contents of a struct entry */ static bool WriteStructEntry(TSharedRef&lt;FDataTableJsonWriter&gt; JsonWriter, const void* InRowData, const UProperty* InProperty, const void* InPropertyData, const EDataTableExportFlags DTExportFlags = EDataTableExportFlags::None); static bool WriteContainerEntry(TSharedRef&lt;FDataTableJsonWriter&gt; JsonWriter, const UProperty* InProperty, const void* InPropertyData, const FString* InIdentifier = nullptr, const EDataTableExportFlags DTExportFlags = EDataTableExportFlags::None); }; .cpp文件，如下所示 // Fill out your copyright notice in the Description page of Project Settings. #include &quot;DataTableLibrary.h&quot; #include &quot;Engine/DataTable.h&quot; #include &quot;DataTableUtils.h&quot; #include &quot;JsonWriter.h&quot; namespace DataTableAlgorithm { /** Returns what string is used as the key/name field for a data table */ FString GetKeyFieldName(const UDataTable&amp; InDataTable); FString GetKeyFieldName(const UDataTable&amp; InDataTable) { FString ExplicitString = InDataTable.ImportKeyField; if (ExplicitString.IsEmpty()) { return TEXT(&quot;Name&quot;); } else { return ExplicitString; } } }// end namespace /** Based on DataTableJSON.cpp -&gt; WriteJSONObjectStartWithOptionalIdentifier() */ void WriteJSONObjectStartWithOptionalIdentifier(FDataTableJsonWriter InJsonWriter, const FString* InIdentifier) { if (InIdentifier) { InJsonWriter.WriteObjectStart(*InIdentifier); } else { InJsonWriter.WriteObjectStart(); } } /** Based on DataTableJSON.cpp -&gt; WriteJSONValueWithOptionalIdentifier() */ template &lt;typename ValueType&gt; void WriteJSONValueWithOptionalIdentifier(FDataTableJsonWriter&amp; InJsonWriter, const FString* InIdentifier, const ValueType InValue) { if (InIdentifier) { InJsonWriter.WriteValue(*InIdentifier, InValue); } else { InJsonWriter.WriteValue(InValue); } } void UDataTableLibrary::GetDataTableAsJSONString(UDataTable* DataTable, FString&amp; JSONString) { // const EDataTableExportFlags InDTExportFlags = EDataTableExportFlags::None; // Construct JsonWriter instance TSharedRef&lt;FDataTableJsonWriter&gt; JsonWriter = TJsonWriterFactory&lt;TCHAR, TPrettyJsonPrintPolicy&lt;TCHAR&gt;&gt;::Create(&amp;JSONString); // Call function to Write DataTable if (!UDataTableLibrary::WriteTable(JsonWriter, *DataTable)) { JSONString = TEXT(&quot;Missing RowStruct!\\n&quot;); } // Close JsonWriter, assign json string to JSONString variable, equal to FDataTableExporterJSON::~FDataTableExporterJSON() JsonWriter-&gt;Close(); } bool UDataTableLibrary::WriteTable(TSharedRef&lt;FDataTableJsonWriter&gt; JsonWriter, const UDataTable&amp; InDataTable) { if (!InDataTable.RowStruct) { return false; } FString KeyField = DataTableAlgorithm::GetKeyFieldName(InDataTable); JsonWriter-&gt;WriteArrayStart(); // Iterate over rows for (auto RowIt = InDataTable.GetRowMap().CreateConstIterator(); RowIt; ++RowIt) { JsonWriter-&gt;WriteObjectStart(); { // RowName const FName RowName = RowIt.Key(); JsonWriter-&gt;WriteValue(KeyField, RowName.ToString()); // Now the values uint8* RowData = RowIt.Value(); UDataTableLibrary::WriteRow(JsonWriter, InDataTable.RowStruct, RowData, &amp;KeyField); } JsonWriter-&gt;WriteObjectEnd(); } JsonWriter-&gt;WriteArrayEnd(); return true; } bool UDataTableLibrary::WriteRow(TSharedRef&lt;FDataTableJsonWriter&gt; JsonWriter, const UScriptStruct* InRowStruct, const void* InRowData, const FString* FieldToSkip /*= nullptr*/) { if (!InRowStruct) { return false; } return UDataTableLibrary::WriteStruct(JsonWriter, InRowStruct, InRowData, FieldToSkip); } bool UDataTableLibrary::WriteStruct(TSharedRef&lt;FDataTableJsonWriter&gt; JsonWriter, const UScriptStruct* InStruct, const void* InStructData, const FString* FieldToSkip /*= nullptr*/, const EDataTableExportFlags DTExportFlags /*= EDataTableExportFlags::None*/) { for (TFieldIterator&lt;const UProperty&gt; It(InStruct); It; ++It) { const UProperty* BaseProp = *It; check(BaseProp); const FString Identifier = DataTableUtils::GetPropertyExportName(BaseProp, DTExportFlags); if (FieldToSkip &amp;&amp; *FieldToSkip == Identifier) { // Skip this field continue; } if (BaseProp-&gt;ArrayDim == 1) { const void* Data = BaseProp-&gt;ContainerPtrToValuePtr&lt;void&gt;(InStructData, 0); UDataTableLibrary::WriteStructEntry(JsonWriter, InStructData, BaseProp, Data); } else { JsonWriter-&gt;WriteArrayStart(Identifier); for (int32 ArrayEntryIndex = 0; ArrayEntryIndex &lt; BaseProp-&gt;ArrayDim; ++ArrayEntryIndex) { const void* Data = BaseProp-&gt;ContainerPtrToValuePtr&lt;void&gt;(InStructData, ArrayEntryIndex); UDataTableLibrary::WriteContainerEntry(JsonWriter, BaseProp, Data); } JsonWriter-&gt;WriteArrayEnd(); } } return true; } bool UDataTableLibrary::WriteStructEntry(TSharedRef&lt;FDataTableJsonWriter&gt; JsonWriter, const void* InRowData, const UProperty* InProperty, const void* InPropertyData, const EDataTableExportFlags DTExportFlags /*= EDataTableExportFlags::None*/) { const FString Identifier = DataTableUtils::GetPropertyExportName(InProperty, DTExportFlags); if (const UEnumProperty* EnumProp = Cast&lt;const UEnumProperty&gt;(InProperty)) { const FString PropertyValue = DataTableUtils::GetPropertyValueAsString(EnumProp, (uint8*)InRowData, DTExportFlags); JsonWriter-&gt;WriteValue(Identifier, PropertyValue); } else if (const UNumericProperty* NumProp = Cast&lt;const UNumericProperty&gt;(InProperty)) { if (NumProp-&gt;IsEnum()) { const FString PropertyValue = DataTableUtils::GetPropertyValueAsString(InProperty, (uint8*)InRowData, DTExportFlags); JsonWriter-&gt;WriteValue(Identifier, PropertyValue); } else if (NumProp-&gt;IsInteger()) { const int64 PropertyValue = NumProp-&gt;GetSignedIntPropertyValue(InPropertyData); JsonWriter-&gt;WriteValue(Identifier, PropertyValue); } else { const double PropertyValue = NumProp-&gt;GetFloatingPointPropertyValue(InPropertyData); JsonWriter-&gt;WriteValue(Identifier, PropertyValue); } } else if (const UBoolProperty* BoolProp = Cast&lt;const UBoolProperty&gt;(InProperty)) { const bool PropertyValue = BoolProp-&gt;GetPropertyValue(InPropertyData); JsonWriter-&gt;WriteValue(Identifier, PropertyValue); } else if (const UArrayProperty* ArrayProp = Cast&lt;const UArrayProperty&gt;(InProperty)) { JsonWriter-&gt;WriteArrayStart(Identifier); FScriptArrayHelper ArrayHelper(ArrayProp, InPropertyData); for (int32 ArrayEntryIndex = 0; ArrayEntryIndex &lt; ArrayHelper.Num(); ++ArrayEntryIndex) { const uint8* ArrayEntryData = ArrayHelper.GetRawPtr(ArrayEntryIndex); UDataTableLibrary::WriteContainerEntry(JsonWriter, ArrayProp-&gt;Inner, ArrayEntryData); } JsonWriter-&gt;WriteArrayEnd(); } else if (const USetProperty* SetProp = Cast&lt;const USetProperty&gt;(InProperty)) { JsonWriter-&gt;WriteArrayStart(Identifier); FScriptSetHelper SetHelper(SetProp, InPropertyData); for (int32 SetSparseIndex = 0; SetSparseIndex &lt; SetHelper.GetMaxIndex(); ++SetSparseIndex) { if (SetHelper.IsValidIndex(SetSparseIndex)) { const uint8* SetEntryData = SetHelper.GetElementPtr(SetSparseIndex); UDataTableLibrary::WriteContainerEntry(JsonWriter, SetHelper.GetElementProperty(), SetEntryData); } } JsonWriter-&gt;WriteArrayEnd(); } else if (const UMapProperty* MapProp = Cast&lt;const UMapProperty&gt;(InProperty)) { JsonWriter-&gt;WriteObjectStart(Identifier); FScriptMapHelper MapHelper(MapProp, InPropertyData); for (int32 MapSparseIndex = 0; MapSparseIndex &lt; MapHelper.GetMaxIndex(); ++MapSparseIndex) { if (MapHelper.IsValidIndex(MapSparseIndex)) { const uint8* MapKeyData = MapHelper.GetKeyPtr(MapSparseIndex); const uint8* MapValueData = MapHelper.GetValuePtr(MapSparseIndex); // JSON object keys must always be strings const FString KeyValue = DataTableUtils::GetPropertyValueAsStringDirect(MapHelper.GetKeyProperty(), (uint8*)MapKeyData, DTExportFlags); UDataTableLibrary::WriteContainerEntry(JsonWriter, MapHelper.GetValueProperty(), MapValueData, &amp;KeyValue); } } JsonWriter-&gt;WriteObjectEnd(); } else if (const UStructProperty* StructProp = Cast&lt;const UStructProperty&gt;(InProperty)) { if (!!(DTExportFlags &amp; EDataTableExportFlags::UseJsonObjectsForStructs)) { JsonWriter-&gt;WriteObjectStart(Identifier); UDataTableLibrary::WriteStruct(JsonWriter, StructProp-&gt;Struct, InPropertyData); JsonWriter-&gt;WriteObjectEnd(); } else { const FString PropertyValue = DataTableUtils::GetPropertyValueAsString(InProperty, (uint8*)InRowData, DTExportFlags); JsonWriter-&gt;WriteValue(Identifier, PropertyValue); } } else { const FString PropertyValue = DataTableUtils::GetPropertyValueAsString(InProperty, (uint8*)InRowData, DTExportFlags); JsonWriter-&gt;WriteValue(Identifier, PropertyValue); } return true; } bool UDataTableLibrary::WriteContainerEntry(TSharedRef&lt;FDataTableJsonWriter&gt; JsonWriter, const UProperty* InProperty, const void* InPropertyData, const FString* InIdentifier /*= nullptr*/, const EDataTableExportFlags DTExportFlags /*= EDataTableExportFlags::None*/) { if (const UEnumProperty* EnumProp = Cast&lt;const UEnumProperty&gt;(InProperty)) { const FString PropertyValue = DataTableUtils::GetPropertyValueAsStringDirect(InProperty, (uint8*)InPropertyData, DTExportFlags); WriteJSONValueWithOptionalIdentifier(*JsonWriter, InIdentifier, PropertyValue); } else if (const UNumericProperty* NumProp = Cast&lt;const UNumericProperty&gt;(InProperty)) { if (NumProp-&gt;IsEnum()) { const FString PropertyValue = DataTableUtils::GetPropertyValueAsStringDirect(InProperty, (uint8*)InPropertyData, DTExportFlags); WriteJSONValueWithOptionalIdentifier(*JsonWriter, InIdentifier, PropertyValue); } else if (NumProp-&gt;IsInteger()) { const int64 PropertyValue = NumProp-&gt;GetSignedIntPropertyValue(InPropertyData); WriteJSONValueWithOptionalIdentifier(*JsonWriter, InIdentifier, PropertyValue); } else { const double PropertyValue = NumProp-&gt;GetFloatingPointPropertyValue(InPropertyData); WriteJSONValueWithOptionalIdentifier(*JsonWriter, InIdentifier, PropertyValue); } } else if (const UBoolProperty* BoolProp = Cast&lt;const UBoolProperty&gt;(InProperty)) { const bool PropertyValue = BoolProp-&gt;GetPropertyValue(InPropertyData); WriteJSONValueWithOptionalIdentifier(*JsonWriter, InIdentifier, PropertyValue); } else if (const UStructProperty* StructProp = Cast&lt;const UStructProperty&gt;(InProperty)) { if (!!(DTExportFlags &amp; EDataTableExportFlags::UseJsonObjectsForStructs)) { WriteJSONObjectStartWithOptionalIdentifier(*JsonWriter, InIdentifier); UDataTableLibrary::WriteStruct(JsonWriter, StructProp-&gt;Struct, InPropertyData); JsonWriter-&gt;WriteObjectEnd(); } else { const FString PropertyValue = DataTableUtils::GetPropertyValueAsStringDirect(InProperty, (uint8*)InPropertyData, DTExportFlags); WriteJSONValueWithOptionalIdentifier(*JsonWriter, InIdentifier, PropertyValue); } } else if (const UArrayProperty* ArrayProp = Cast&lt;const UArrayProperty&gt;(InProperty)) { // Cannot nest arrays return false; } else if (const USetProperty* SetProp = Cast&lt;const USetProperty&gt;(InProperty)) { // Cannot nest sets return false; } else if (const UMapProperty* MapProp = Cast&lt;const UMapProperty&gt;(InProperty)) { // Cannot nest maps return false; } else { const FString PropertyValue = DataTableUtils::GetPropertyValueAsStringDirect(InProperty, (uint8*)InPropertyData, DTExportFlags); WriteJSONValueWithOptionalIdentifier(*JsonWriter, InIdentifier, PropertyValue); } return true; } 由于在DataTableLibrary.cpp的#include文件中包含了&quot;JsonWriter.h&quot;，该头文件属于Json模块，因此在UDataTableLibrary类所属模块的编译文件（Build.cs文件）中需引入Json模块，如下代码所示位置 PrivateDependencyModuleNames.AddRange( new string[] { &quot;CoreUObject&quot;, &quot;Engine&quot;, &quot;Slate&quot;, &quot;SlateCore&quot;, // ... add private dependencies that you statically link with here ... &quot;JsonUtilities&quot;, &quot;Json&quot;, } ); 接下来，剖析上述改写代码形成的过程 改写UDataTable类成员函数GetTableAsJSON()重点在于改写class FDataTableExporterJSON 类，而改写class FDataTableExporterJSON类的关键在于如何处理它的3个成员变量，这3个成员变量在构造函数中被初始化。 EDataTableExportFlags DTExportFlags; TSharedRef&lt;FDataTableJsonWriter&gt; JsonWriter; bool bJsonWriterNeedsClose; FDataTableExporterJSON类的成员变量； FDataTableExporterJSON::FDataTableExporterJSON(const EDataTableExportFlags InDTExportFlags, FString&amp; OutExportText) : DTExportFlags(InDTExportFlags) , JsonWriter(TJsonWriterFactory&lt;TCHAR, TPrettyJsonPrintPolicy&lt;TCHAR&gt;&gt;::Create(&amp;OutExportText)) , bJsonWriterNeedsClose(true) { } FDataTableExporterJSON::FDataTableExporterJSON(const EDataTableExportFlags InDTExportFlags, TSharedRef&lt;FDataTableJsonWriter&gt; InJsonWriter) : DTExportFlags(InDTExportFlags) , JsonWriter(InJsonWriter) , bJsonWriterNeedsClose(false) { } FDataTableExporterJSON类的构造函数源代码； FDataTableExporterJSON类的构造函数 (1) EDataTableExportFlags DTExportFlags; 从UDataTable类的成员函数声明FString GetTableAsJSON(const EDataTableExportFlags InDTExportFlags = EDataTableExportFlags::None) const，不难看出，成员变量EDataTableExportFlags DTExportFlags可以使用GetTableAsJSON函数参数默认值EDataTableExportFlags::None，并且从FDataTableExporterJSON类的各成员函数的函数体代码中，不难发现成员变量DTExportFlags值始终保持不变。按照修改最小化原则，不妨在相应的改写函数的参数列表中添加该同名参数并赋予默认值EDataTableExportFlags::None，这样既可以不修改函数体内部代码，又可以减少函数调用时参数传递的个数。 (2) TSharedRef JsonWriter; 首先，仿照FDataTableExporterJSON::FDataTableJsonWriter，在UDataTableLibrary类.h文件中声明FDataTableJsonWriter类型 /** Based on FDataTableExporterJSON::FDataTableJsonWriter */ typedef TJsonWriter&lt;TCHAR, TPrettyJsonPrintPolicy&lt;TCHAR&gt;&gt; FDataTableJsonWriter; 然后，仿照FDataTableExporterJSON类的构造函数，在UDataTableLibrary :: GetDataTableAsJSONString()函数中定义并初始化JsonWriter变量， TSharedRef&lt;FDataTableJsonWriter&gt; JsonWriter = TJsonWriterFactory&lt;TCHAR, TPrettyJsonPrintPolicy&lt;TCHAR&gt;&gt;::Create(&amp;JSONString); 最后在改写FDataTableExporterJSON成员函数时，若函数体中存在JsonWriter成员变量，则在同名的改写函数参数列表中添加参数TSharedRef JsonWriter。 (3) bool bJsonWriterNeedsClose; 从FDataTableExporterJSON类源代码中不难发现，bJsonWriterNeedsClose变量只出现在类的构造和析构函数中，且只用于判断是否执行JsonWriter-&gt;Close()。 FDataTableExporterJSON::~FDataTableExporterJSON() { if (bJsonWriterNeedsClose) { JsonWriter-&gt;Close(); } } FDataTableExporterJSON类的析构函数； 在执行UDataTable::GetTableAsJSON()函数体时，在执行FDataTableExporterJSON类构造函数时，bJsonWriterNeedsClose被赋值true；也就是调用UDataTable::GetTableAsJSON()函数需要执行JsonWriter-&gt;Close()。不妨直接把JsonWriter-&gt;Close()放在UDataTableLibrary::WriteTable()被调用之后，如上述UDataTableLibrary::GetDataTableAsJSONString()函数体代码所示位置。 在了解如何处理上述3个成员变量之后，其它工作就是直接从FDataTableExporterJSON类中copy代码了，稍微改写下函数原型，并在改写函数被调用处增加JsonWriter参数。 4. Usage 图1. GetTableAsJsonString蓝图函数； 图2. 输出Log； 5. Conclusion 本文以改写UDataTable类成员函数GetTableAsJSON()为例，介绍了改写UE4引擎源代码的过程，以实现自己想要的功能。既是对上一期读写DataTable数据表的功能完善，也是想要通过案例，来传递一种想法，虚幻程序员应当尽力挖掘引擎源代码，补充、修改、完善更多引擎功能。 ","link":"https://xusjtuer.github.io/post/ue4-post7_rewrite_source_code_and_examples/"},{"title":"UE4 动态读写DataTable数据表","content":"1. Overview DataTable数据表在UE4中是一类重要的资产(Asset)，截至ue4 v4.25版本，引擎内置的函数并不支持运行时(Runtime)修改DataTable表，所以写下本教程，讲解如何在ue4中实现动态修改DataTable数据表。如下图所示函数，由于其功能和ue4内置的DataTable编辑脚本(EditorScript)相同，所以仿照源码取了相同的函数名称，但以下蓝图节点在打包之后仍然可以调用。 图1. 动态读写DataTable的自定义蓝图节点； 2. Introduction DataTable数据表在ue4开发中应用广泛，特别是，在进行数据驱动开发时具有举足轻重的地位；但是ue4引擎暴露出来函数中，能够对DataTable表进行编辑的函数却特别少，其中还有一些函数被WITH_EDITOR宏包裹着，属于编辑器脚本 (Editor Script)，无法在项目打包之后调用。要想对DataTable进行更多样的操作，只有自己创建c++函数来实现动态读写DataTable功能。 #if WITH_EDITOR /** * Empty and fill a Data Table from CSV string. * @param CSVString The Data that representing the contents of a CSV file. * @return True if the operation succeeds, check the log for errors if it didn't succeed. */ UFUNCTION(BlueprintCallable, Category = &quot;Editor Scripting | DataTable&quot;, DisplayName=&quot;Fill Data Table from CSV String&quot;) static bool FillDataTableFromCSVString(UDataTable* DataTable, const FString&amp; CSVString); /** * Empty and fill a Data Table from CSV file. * @param CSVFilePath The file path of the CSV file. * @return True if the operation succeeds, check the log for errors if it didn't succeed. */ UFUNCTION(BlueprintCallable, Category = &quot;Editor Scripting | DataTable&quot;, DisplayName = &quot;Fill Data Table from CSV File&quot;) static bool FillDataTableFromCSVFile(UDataTable* DataTable, const FString&amp; CSVFilePath); /** * Empty and fill a Data Table from JSON string. * @param JSONString The Data that representing the contents of a JSON file. * @return True if the operation succeeds, check the log for errors if it didn't succeed. */ UFUNCTION(BlueprintCallable, Category = &quot;Editor Scripting | DataTable&quot;, DisplayName = &quot;Fill Data Table from JSON String&quot;) static bool FillDataTableFromJSONString(UDataTable* DataTable, const FString&amp; JSONString); /** * Empty and fill a Data Table from JSON file. * @param JSONFilePath The file path of the JSON file. * @return True if the operation succeeds, check the log for errors if it didn't succeed. */ UFUNCTION(BlueprintCallable, Category = &quot;Editor Scripting | DataTable&quot;, DisplayName = &quot;Fill Data Table from JSON File&quot;) static bool FillDataTableFromJSONFile(UDataTable* DataTable, const FString&amp; JSONFilePath); #endif //WITH_EDITOR DataTableFunctionLibrary类的Editor Script写入DataTable； 3. Why 首先想要简要叙述以下二个问题： (1) 为什么需要动态读写DataTable？ 最大的好处是便于修改，打包之后可修改DataTable数据表中的数据，无需重复打包。目前引擎默认的功能中DataTable只允许在编辑器中编辑，或者在编辑时导入相同格式的CSV文件/JSON文件，这些功能在项目打包之后都是无法使用的；所以一般情况下，在修改DataTable中的数据之后，只能重新打包项目，费时费力。要想避免此类重复打包，实现动态读写DataTable就意义非凡了。 (2) 实现动态读写DataTable的原理? DataTable写操作过程： 从ue4 源码DataTable.h和DataTableFunctionLibrary.h二个类中不难发现，DataTable支持动态读写操作的，其中UDataTable::CreateTableFromCSVString()和UDataTable :: CreateTableFromJSONString()二个函数尤其值得注意，这二个函数并未被WITH_EDITOR宏包裹，也就是在非编辑器模式下，仍可被调用。而二种函数中的输入参数CSVSting和JSONString既可以通过本地磁盘文件获得，也可以使用HTTP网络传输的数据来获得。所以在获得CSVString/JSONString之后，调用这二个函数，即可实现向DataTable中写入数据。 /** * Create table from CSV style comma-separated string. * RowStruct must be defined before calling this function. * @return Set of problems encountered while processing input */ ENGINE_API TArray&lt;FString&gt; CreateTableFromCSVString(const FString&amp; InString); /** * Create table from JSON style string. * RowStruct must be defined before calling this function. * @return Set of problems encountered while processing input */ ENGINE_API TArray&lt;FString&gt; CreateTableFromJSONString(const FString&amp; InString); 源码DataTable.h中的函数； DataTable读操作过程： 从DataTable的Editor Script不难看出DataTable可以逆序列化为CSV文件和JSON文件，以下GetTableAsCSVFile方法将DataTable每个数据转换成String类型，按照CSV文件格式保存成CSV文件。 4. Approach 自定义动态读写DataTable的蓝图节点，实现过程大致如下： （1） 以UBlueprintFunctionLibrary为基类，创建C++类，该类的.h文件，主要代码如下： 包含的头文件： #pragma once #include &quot;CoreMinimal.h&quot; #include &quot;Kismet/BlueprintFunctionLibrary.h&quot; #include &quot;Engine/DataTable.h&quot; #include &quot;GenericArrayLibrary.generated.h&quot; 自定义了一个LogCategory，用于分类LOG // Declare General Log Category, header file .h DECLARE_LOG_CATEGORY_EXTERN(LogUtiliesNode, Log, All); 函数声明 /** * Empty and fill a Data Table from CSV string. * @param CSVString The Data that representing the contents of a CSV file. * @return True if the operation succeeds, check the log for errors if it didn't succeed. */ UFUNCTION(BlueprintCallable, DisplayName = &quot;Fill Data Table from CSV String&quot;, Category = &quot;DataTable&quot;) static bool FillDataTableFromCSVString(UDataTable* DataTable, const FString&amp; CSVString); /** * Empty and fill a Data Table from CSV file. * @param CSVFilePath The file path of the CSV file. * @return True if the operation succeeds, check the log for errors if it didn't succeed. */ UFUNCTION(BlueprintCallable, DisplayName = &quot;Fill Data Table from CSV File&quot;, Category = &quot;DataTable&quot;) static bool FillDataTableFromCSVFile(UDataTable* DataTable, const FString&amp; CSVFilePath); /** * Empty and fill a Data Table from JSON string. * @param JSONString The Data that representing the contents of a JSON file. * @return True if the operation succeeds, check the log for errors if it didn't succeed. */ UFUNCTION(BlueprintCallable, DisplayName = &quot;Fill Data Table from JSON String&quot;, Category = &quot;DataTable&quot;) static bool FillDataTableFromJSONString(UDataTable* DataTable, const FString&amp; JSONString); /** * Empty and fill a Data Table from JSON file. * @param JSONFilePath The file path of the JSON file. * @return True if the operation succeeds, check the log for errors if it didn't succeed. */ UFUNCTION(BlueprintCallable, DisplayName = &quot;Fill Data Table from JSON File&quot;, Category = &quot;DataTable&quot;) static bool FillDataTableFromJSONFile(UDataTable* DataTable, const FString&amp; JSONFilePath); /** Output entire contents of table as CSV string */ UFUNCTION(BlueprintCallable, DisplayName = &quot;Get Table As CSV String&quot;, Category = &quot;DataTable&quot;) static void GetDataTableAsCSVString(UDataTable* DataTable, FString&amp; CSVString); /** Output entire contents of table as CSV File */ UFUNCTION(BlueprintCallable, DisplayName = &quot;Get Table As CSV File&quot;, Category = &quot;DataTable&quot;) static void GetDataTableAsCSVFile(UDataTable* DataTable, const FString&amp; CSVFilePath); 该类.cpp文件中，包含的头文件： #include &quot;GenericArrayLibrary.h&quot; #include &quot;HAL/PlatformFilemanager.h&quot; #include &quot;Misc/FileHelper.h&quot; #include &quot;DataTableUtils.h&quot; 声明Log Category //Declare General Log Category, source file .cpp DEFINE_LOG_CATEGORY(LogUtiliesNode); 函数实现： bool UGenericMiscLibrary::FillDataTableFromCSVString(UDataTable* DataTable, const FString&amp; CSVString) { if (!DataTable || (CSVString.Len() == 0)) { UE_LOG(LogUtiliesNode, Warning, TEXT(&quot;FillDataTableFromCSVString -&gt; Can't fill DataTable with CSVString: %.&quot;), *CSVString); return false; } // Call bulit-in function TArray&lt;FString&gt; Errors = DataTable-&gt;CreateTableFromCSVString(CSVString); if (Errors.Num()) { // It has some error message for (const FString&amp; Error : Errors) { UE_LOG(LogUtiliesNode, Warning, TEXT(&quot;%s&quot;), *Error); } return false; } return true; } bool UGenericMiscLibrary::FillDataTableFromCSVFile(UDataTable* DataTable, const FString&amp; CSVFilePath) { FString CSVString; if (FPlatformFileManager::Get().GetPlatformFile().FileExists(*CSVFilePath)) { // Supports all combination of ANSI/Unicode files and platforms. FFileHelper::LoadFileToString(CSVString, *CSVFilePath); } else { UE_LOG(LogUtiliesNode, Warning, TEXT(&quot;FillDataTableFromCSVFile -&gt; Cannot find CSV file %s&quot;), *CSVFilePath); return false; } return UGenericMiscLibrary::FillDataTableFromCSVString(DataTable, CSVString); } bool UGenericMiscLibrary::FillDataTableFromJSONString(UDataTable* DataTable, const FString&amp; JSONString) { if (!DataTable || (JSONString.Len() == 0)) { UE_LOG(LogUtiliesNode, Warning, TEXT(&quot;FillDataTableFromJSONString -&gt; Can't fill DataTable with JSONString: %.&quot;), *JSONString); return false; } // Call bulit-in function TArray&lt;FString&gt; Errors = DataTable-&gt;CreateTableFromJSONString(JSONString); if (Errors.Num()) { // It has some error message for (const FString&amp; Error : Errors) { UE_LOG(LogUtiliesNode, Warning, TEXT(&quot;%s&quot;), *Error); } return false; } return true; } bool UGenericMiscLibrary::FillDataTableFromJSONFile(UDataTable* DataTable, const FString&amp; JSONFilePath) { FString JSONString; if (FPlatformFileManager::Get().GetPlatformFile().FileExists(*JSONFilePath)) { // Supports all combination of ANSI/Unicode files and platforms. FFileHelper::LoadFileToString(JSONString, *JSONFilePath); } else { UE_LOG(LogUtiliesNode, Warning, TEXT(&quot;FillDataTableFromJSONFile -&gt; Cannot find CSV file %s&quot;), *JSONFilePath); return false; } return UGenericMiscLibrary::FillDataTableFromJSONString(DataTable, JSONString); } void UGenericMiscLibrary::GetDataTableAsCSVString(UDataTable* DataTable, FString&amp; CSVString) { CSVString = FString(); if (!DataTable || (DataTable-&gt;RowStruct == nullptr)) { UE_LOG(LogTemp, Warning, TEXT(&quot;UGenericMiscLibrary::GetTableAsCSV : Missing DataTable or RowStruct !&quot;)); return; } // First build array of properties TArray&lt;FProperty*&gt; StructProps; for (TFieldIterator&lt;FProperty&gt; It(DataTable-&gt;RowStruct); It; ++It) { FProperty* Prop = *It; check(Prop != nullptr); StructProps.Add(Prop); } // First row, column titles, taken from properties CSVString += TEXT(&quot;---&quot;); for (int32 PropIdx = 0; PropIdx &lt; StructProps.Num(); PropIdx++) { CSVString += TEXT(&quot;,&quot;); CSVString += StructProps[PropIdx]-&gt;GetName(); } CSVString += TEXT(&quot;\\n&quot;); // Now iterate over rows for (auto RowIt = DataTable-&gt;GetRowMap().CreateConstIterator(); RowIt; ++RowIt) { FName RowName = RowIt.Key(); CSVString += RowName.ToString(); uint8* RowData = RowIt.Value(); for (int32 PropIdx = 0; PropIdx &lt; StructProps.Num(); PropIdx++) { CSVString += TEXT(&quot;,&quot;); CSVString += DataTableUtils::GetPropertyValueAsString(StructProps[PropIdx], RowData, EDataTableExportFlags::None); } CSVString += TEXT(&quot;\\n&quot;); } } void UGenericMiscLibrary::GetDataTableAsCSVFile(UDataTable* DataTable, const FString&amp; CSVFilePath) { FString CSVString; UGenericMiscLibrary::GetDataTableAsCSVString(DataTable, CSVString); if (CSVString.Len() == 0) { return; } FFileHelper::SaveStringToFile(CSVString, *CSVFilePath, FFileHelper::EEncodingOptions::ForceUTF8); } 编译成功之后，即可获得以上6个节点。 5. Usage 在c++类中自定义结构体，并且继承FTableRowBase类，以下示例使用的结构体如下： /** Comment */ USTRUCT(BlueprintType) struct FYourCppStruct : public FTableRowBase { GENERATED_USTRUCT_BODY() UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = &quot;YourCppStruct&quot;) int32 IntegerValue; UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = &quot;YourCppStruct&quot;) float FloatValue; UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = &quot;YourCppStruct&quot;) FString StingValue; UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = &quot;YourCppStruct&quot;) FTransform TransformValue; UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = &quot;YourCppStruct&quot;) TArray&lt;int32&gt; ArrayValue; UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = &quot;YourCppStruct&quot;) TSet&lt;int32&gt; SetValue; UPROPERTY(BlueprintReadWrite, EditAnywhere, Category = &quot;YourCppStruct&quot;) TMap&lt;int32, FString&gt; MapValue; }; **特别提醒：此结构体必须在c++中定义，**原因在于Cpp Struct和BP Struct在反射和继承等特征上并非是等价的，。 编译结束之后，创建以该结构体为RowStruct的DataTable表 图2. 使用在Cpp中定义的结构体，创建DataTable； 蓝图中使用示例，以CSV文件读写DataTable为例，(注意：CSV文件/Json文件需和从引擎中DataTable导出的CSV/Json文件，在文件内容采用相同格式) 图3. 使Fill Data Table From CSV File和Get Table As CSV File节点使用示例； 6. Conclusion 本文主要介绍了ue4中动态读写DataTable表方法，实现了CSV/JSON格式数据直接写入DataTable中功能，同时也支持将DataTable数据表导出成CSV数据，完全可以满足对DataTable数据表的动态读写操作。不足之处：将DataTable导出成可读性更高的JSON文件 (Get Table As Json File) 没有完成。 以上内容其实属于对整个DataTable的操作，还有对DataTable的行（Row），属性(Property)进行操作的方法，如下。 ","link":"https://xusjtuer.github.io/post/ue4-post6_dynamic_read_write_datatable/"},{"title":"UE4 基于CustomThunk的泛型蓝图节点语法规范 (二)","content":"1. Overview 上一期讲述了CustomThunk方式实现泛型蓝图节点中前二部分，泛型蓝图节点的声明以及自定义Thunk函数体的方法，本期将继续介绍第三部分：泛型函数（Generic）的实现。虽然不同泛型蓝图节点的功能千差万别，泛型函数代码也可能迥然不同，但是ue4编写中泛型函数与编写一般的c++函数完全相同。接下来将结合具体实例（如下图所示的3个泛型蓝图节点），让大家更全面的了解泛型蓝图节点的实现过程。特别提醒：在查看本期内容之前，请先了解上一期的内容。 图1. 泛型蓝图节点； 2. Approach 2.1 Struct to Json String节点 功能：将任意类型结构体UStruct转换Json格式字符串 图2. UStruct to Json String 使用示例； 图3. UStruct to Json String 输出结果； 首先，在该模块的Build.cs文件中引入JsonUtilities,和Json模块，如下代码所示位置 PrivateDependencyModuleNames.AddRange( new string[] { &quot;CoreUObject&quot;, &quot;Engine&quot;, &quot;Slate&quot;, &quot;SlateCore&quot;, // ... add private dependencies that you statically link with here ... &quot;JsonUtilities&quot;, &quot;Json&quot;, } ); 由于UStruct to Json String的泛型函数，在源代码JsonObjectConverter.h中已经存在了，所以无需自己编写泛型函数，直接调用即可。 代码实现如下： //h 文件，引入头文件 #include &quot;JsonObjectConverter.h&quot; /** * Save any type of struct object to JSON format string, no struct type restriction * * @param StructReference The UStruct instance to read from * @return JSON String Json Object string to be filled in with data from the ustruct */ UFUNCTION(BlueprintPure, CustomThunk, meta = (CustomStructureParam = &quot;StructReference&quot;, DisplayName = &quot;Struct to JSON String&quot;), Category = &quot;File|Json&quot;) static void UStructToJsonObjectString(const int32&amp; StructReference, FString&amp; JSONString); /// Custom execFunciton thunk for function UStructToJsonObjectString. DECLARE_FUNCTION(execUStructToJsonObjectString) { //Get input wildcard single variable Stack.Step(Stack.Object, NULL); UStructProperty* StructProperty = ExactCast&lt;UStructProperty&gt;(Stack.MostRecentProperty); void* StructPtr = Stack.MostRecentPropertyAddress; //Get JsonString reference P_GET_PROPERTY_REF(UStrProperty, JSONString); P_FINISH; P_NATIVE_BEGIN; FJsonObjectConverter::UStructToJsonObjectString(StructProperty-&gt;Struct, StructPtr, JSONString, 0, 0); P_NATIVE_END; } 特别提醒：从UStruct to Json String 输出截图，可以看到ue4内置的 FJsonObjectConverter :: UStructToJsonObjectString()函数存在二个小问题：其一：结构体的变量名首字母被改成小写字母；其二：在蓝图中定义的结构体的变量名与转换后JSONString中的变量名存在明显差异，原因在于如下图所示的源代码第 261行。修复方法：可以用一个自定义函数获取VariableName，请自行修复。 图4. UStructToJsonObjectString问题源代码； 2.2 Is Valid Index节点 功能：判断TargetArray是否(length &gt; 0)为空，若为非空（length&gt;0），执行IsValid PIN执行流引脚；如为空(length==0)，执行Is Not Valid PIN执行流引脚，等价于如下图所示的蓝图宏 图5. Is Valid节点等价蓝图宏； 图6. Is Valid节点使用示例； 图7. Is Valid节点输出Log； 由于Is Valid节点含有多个输出执行流引脚，需要使用&quot;ExpandEnumAsExecs&quot;说明符，将枚举类型的成员作为执行流引脚。 Is Valid泛型蓝图节点实现代码： 实现定义执行流引脚的枚举类型（.h文件） // Expand Enum As Execs UENUM() enum class EEvaluateArray : uint8 { /** Array length &gt; 0. */ IsValid, /** Array length == 0. */ IsNotValid }; // .h文件，声明泛型蓝图节点，实现Thunk函数体 /* *Determines if an aray is valid(length &gt; 0) ? * *@param TargetArray The array to get the length */ UFUNCTION(BlueprintCallable, CustomThunk, meta = (DisplayName = &quot;Is Valid ?&quot;, ArrayParm = &quot;TargetArray&quot;, Keywords = &quot;num, size,valid&quot;,ExpandEnumAsExecs = &quot;EvaluateArrayPIN&quot;, BlueprintThreadSafe), Category = &quot;Utilities|Array&quot;) static void Array_Validv2(const TArray&lt;int32&gt;&amp; TargetArray, EEvaluateArray&amp; EvaluateArrayPIN); static void GenericArray_Validv2(void* ArrayAddr, UArrayProperty* ArrayProperty, EEvaluateArray&amp; EvaluateArrayPIN); DECLARE_FUNCTION(execArray_Validv2) { Stack.MostRecentProperty = nullptr; Stack.StepCompiledIn&lt;UArrayProperty&gt;(NULL); void* ArrayAddr = Stack.MostRecentPropertyAddress; UArrayProperty* ArrayProperty = Cast&lt;UArrayProperty&gt;(Stack.MostRecentProperty); if (!ArrayProperty) { Stack.bArrayContextFailed = true; return; } P_GET_ENUM_REF(EEvaluateArray, EvaluateArrayPIN); P_FINISH; P_NATIVE_BEGIN; GenericArray_Validv2(ArrayAddr, ArrayProperty, EvaluateArrayPIN); P_NATIVE_END; } // .cpp文件，实现泛型函数 void UMiscAlgorithm::GenericArray_Validv2(void* ArrayAddr, UArrayProperty* ArrayProperty, EEvaluateArray&amp; EvaluateArrayPIN) { // Determine whether the array length is greater than 0 bool bValidArray = UKismetArrayLibrary::GenericArray_Length(ArrayAddr, ArrayProperty) &gt; 0; if (bValidArray == true) { // Exec IsValid PIN EvaluateArrayPIN = EEvaluateArray::IsValid; } else { // Exec Is Not Valid PIN EvaluateArrayPIN = EEvaluateArray::IsNotValid; } } 2.3 Filter Array节点 功能：根据在蓝图中自定义的筛选函数FilterBy，筛选数组成员 图8. Filter 泛型蓝图节点使用示例； 自定义筛选函数 FilterBy，必须为二个参数；第一个为输入参数，类型与数组类型相同；第二个为返回值，类型为bool，并命名为&quot;ReturnValue&quot;。如下图所示，筛选字符串数组中字符长度在5和8之间的字符串。 图9. 自定义筛选函数示例； 图10. Filter节点输入Log； Filter节点实现代码如下： // .h文件 /* *Filter an array based on filter function of object. * *@param Object The owner of function *@param FilterBy Filter function name, this custom function with 2 parameters, 1 input (Type same as array member), 1 return named &quot;ReturnValue&quot;(bool) *@param TargetArray The array to filter from *@return An array containing only those members which meet the filterBy condition. */ UFUNCTION(BlueprintCallable, CustomThunk, meta = (DisplayName = &quot;Filter Array&quot;, CompactNodeTitle = &quot;Filter&quot;, ArrayParm = &quot;TargetArray,FilteredArray&quot;, ArrayTypeDependentParams = &quot;TargetArray,FilteredArray&quot;, AutoCreateRefTerm = &quot;FilteredArray&quot;, DefaultToSelf = &quot;Object&quot;, AdvancedDisplay = &quot;Object&quot;), Category = &quot;Utilities|Array&quot;) static void Array_Filter(const UObject* Object, const FName FilterBy, const TArray&lt;int32&gt;&amp; TargetArray, TArray&lt;int32&gt;&amp; FilteredArray); static void GenericArray_Filter(UObject* Object, UFunction* FilterFunction, const UArrayProperty* ArrayProp, void* SrcArrayAddr, void* FilterArrayAddr); DECLARE_FUNCTION(execArray_Filter) { P_GET_OBJECT(UObject, OwnerObject); P_GET_PROPERTY(UNameProperty, FilterBy); //Find filter function UFunction* const FilterFunction = OwnerObject-&gt;FindFunction(FilterBy); // Fitler function must have two parameters(1 input / 1 output) if (!FilterFunction || (FilterFunction-&gt;NumParms != 2)) { UE_LOG(LogTemp, Warning, TEXT(&quot;Tooltip -&gt; Array_Filter -&gt; Please check filter function %s &quot;), *FilterBy.ToString()); return; } // Get target array address and ArrayProperty Stack.MostRecentProperty = nullptr; Stack.StepCompiledIn&lt;UArrayProperty&gt;(NULL); void* SrcArrayAddr = Stack.MostRecentPropertyAddress; UArrayProperty* SrcArrayProperty = Cast&lt;UArrayProperty&gt;(Stack.MostRecentProperty); if (!SrcArrayProperty) { Stack.bArrayContextFailed = true; return; } // Get filtered array address and arrayproperty Stack.MostRecentProperty = nullptr; Stack.StepCompiledIn&lt;UArrayProperty&gt;(NULL); void* FilterArrayAddr = Stack.MostRecentPropertyAddress; UArrayProperty* FilterArrayProperty = Cast&lt;UArrayProperty&gt;(Stack.MostRecentProperty); if (!FilterArrayProperty) { Stack.bArrayContextFailed = true; return; } P_FINISH; P_NATIVE_BEGIN; // ScrArrayProperty is equal to FilterArrayProperty GenericArray_Filter(OwnerObject, FilterFunction, SrcArrayProperty, SrcArrayAddr, FilterArrayAddr); P_NATIVE_END; } // .cpp文件 void UMiscAlgorithm::GenericArray_Filter(UObject* Object, UFunction* FilterFunction, const UArrayProperty* ArrayProp, void* SrcArrayAddr, void* FilterArrayAddr) { //check input parameters if (!Object || !FilterFunction || !SrcArrayAddr) { return; } // filter function return property UBoolProperty* ReturnProp = Cast&lt;UBoolProperty&gt;(FilterFunction-&gt;GetReturnProperty()); if (!ReturnProp) { /// The return Property of filter function must be bool and named &quot;ReturnValue&quot; UE_LOG(LogTemp, Warning, TEXT(&quot;Tooltip -&gt; GenericArray_Filter -&gt; Pleas check return value of filter function.(Type:bool, Name:ReturnValue)&quot;)); return; } // Get function parameter list TArray&lt;UProperty*&gt; ParamterList; for (TFieldIterator&lt;UProperty&gt; It(FilterFunction); It; ++It) { UProperty* FuncParameter = *It; /// Get filter function parameters ParamterList.Emplace(FuncParameter); } /// Make sure the first input parameters of filter function is same to array inner if (!ParamterList[0]-&gt;SameType(ArrayProp-&gt;Inner)) { /// The property of 1st input parameter of filter function must be same as array member UE_LOG(LogTemp, Warning, TEXT(&quot;Tooltip -&gt; GenericArray_Filter -&gt; Pleas check input parameter of filter function.(Type is same as array member)&quot;)); return; } FScriptArrayHelper ArrayHelper(ArrayProp, SrcArrayAddr); FScriptArrayHelper FilterArray(ArrayProp, FilterArrayAddr); UProperty* InnerProp = ArrayProp-&gt;Inner; const int32 PropertySize = InnerProp-&gt;ElementSize * InnerProp-&gt;ArrayDim; // filter function parameters address, 1 input parameter(array item) and 1 return parameter (bool) uint8* FilterParamsAddr = (uint8*)FMemory::Malloc(PropertySize + 1); for (int32 i = 0; i &lt; ArrayHelper.Num(); i++) { FMemory::Memzero(FilterParamsAddr, PropertySize + 1); // get array member and assign value to filter function input parameter InnerProp-&gt;CopyCompleteValueFromScriptVM(FilterParamsAddr, ArrayHelper.GetRawPtr(i)); //process filter function Object-&gt;ProcessEvent(FilterFunction, FilterParamsAddr); if (ReturnProp &amp;&amp; ReturnProp-&gt;GetPropertyValue(FilterParamsAddr + PropertySize)) { // add item to filter array UKismetArrayLibrary::GenericArray_Add(FilterArrayAddr, ArrayProp, ArrayHelper.GetRawPtr(i)); } } // relesed memory FMemory::Free(FilterParamsAddr); } 以上节点源代码可见：https://github.com/xusjtuer/NoteUE4 3. Conclusion 总结：到目前为止，已经使用泛型蓝图节点实现了多种功能，第2期 任意类型数组排序SORT节点，第3期 Object任意类型属性的GET/SET节点，以及这一期介绍的3个节点：任意类型结构体转字符串StructToJsonObjectString节点、判断数组是否为空IsValid节点、以及数组筛选Filter节点。泛型蓝图节点更多的应用，需要在实践中不断发掘与探索。未来，自己也会尝试将一些泛型蓝图节点提交到引擎源码中去，也是为虚幻引擎做出贡献。 至此，基于CustomThunk的泛型蓝图节点实现过程已经全部讲完了，以上内容如觉有帮助，请不吝点赞；如觉无聊，可一带而过。 ","link":"https://xusjtuer.github.io/post/ue4-post5_generic_bluerpint_function_customthunk2/"},{"title":"UE4 基于CustomThunk的泛型蓝图节点语法规范 (一)","content":"1. Overview 本教程旨在讲解基于CustomThunk方式实现泛型蓝图节点的语法规范，主要包括泛型蓝图节点的组成，泛型蓝图节点的声明，自定义Thunk函数体实现，泛型函数（Generic）的实现案例。因内容较多，故分成二期。如觉有帮助，请不吝点赞；如觉无聊，可一带而过。 2. Introduction 正如前面二期介绍的泛型蓝图节点的应用实例（SORT和GET/SET），泛型蓝图节点应用广泛，并且极大的扩展了蓝图系统的便利性。不同的类型，相同的操作可以使用同一个蓝图节点来完成，减少了代码冗余。本次教程承接上一期内容，继续介绍基于CustomThunk方法的泛型蓝图节点语法规范和实现方式，以下内容为个人分析源码经验所得，如有错漏，敬请谅解，并欢迎在下方评论区中指出，或补充更多相关信息。 CustomThunk和UK2Node都可以实现泛型蓝图节点，二种实现方法大相径庭，实现难易程度也相差很远，具体选择哪一种方法应当考虑一下情况： 1）meta说明符功能可以满足要求时，建议优先使用CustomThunk方法，理由：代码少，debug方便； 以下二种情形，建议使用UK2Node方法： 情形一：在编辑模式（Editor）下（非运行状态）需要“修改”蓝图节点引脚（PIN），例如动态增加或删除蓝图节点PIN。 情形二：当使用CustomThunk方式实现的泛型蓝图节点时，程序员对蓝图引脚的控制只有通过meta说明符，而目前meta说明符功能仍存在部分限制。举例，如ue4内置GetDataTableRow蓝图节点一样，该节点的OutRow 引脚（wildcard PIN）需要根据DataTable 引脚输入的DataTable表动态更改OutRow类型；虽然CustomThunk方法也能实现动态改变引脚类型，但是对于此类情况却无法处理。 3. Required Knowledge ue4 c++ 类的创建以及c++中定义蓝图可调用函数； 熟悉ue4 c++ UFUNCTION宏中常用说明符以及meta说明符； 4. Approach 4.1 泛型蓝图节点c++函数组成 查看UE4源代码（在整个解决方案中查找关键字CustomThunk），不难发现绝大多数泛型的蓝图节点的c++ 实现包括三个组成部分：（1）带有UFUNCTION宏的函数声明；（2） 自定义Thunk函数体DECLARE_FUNCTION(execFunctionName)；（3）真正执行泛型逻辑的Generic_FunctionName()泛型函数。 第（1）部分，限定了在蓝图系统中该函数以蓝图节点方式出现时的样式，包括函数名、参数列表、返回值以及泛型参数等。UFUNCTION宏中包含CustomThunk说明符，其中泛型参数及依赖关系由meta说明符列表决定。 第（2）部分，定义了泛型蓝图函数的Thunk函数体，其实质作用在于运行（Runtime）时获取从蓝图虚拟机VM中传递的参数，其形式规定为 DECLARE_FUNCTION(execFunctionName){}， Function Name为第（1） 部分声明的函数名。 第（3）部分，在完整获得蓝图传递的参数之后，调用蓝图函数的泛型版本，也就是第（3）部分定义的泛型函数。该函数是真正执行泛型功能的代码块，如第2期的数组排序功能，第3期的属性GET/SET功能。此函数命名并无强制性要求，可以选择任意合法的函数名，为了便于理解，源代码中一般采用Generic_（Generic）+ FunctionName的形式，Generic的含义就是通常所说的泛型。 4.2 泛型蓝图函数声明 如蓝图系统中的变量类型（Variable Type）一样，标识泛型函数通配符(wildcard)参数的说明符也有四种，分别为标识单个变量SingleVariable wildcard类型的&quot;CustomStructureParam&quot;说明符、标识容器Array的&quot;ArrayParm&quot;说明符、标识容器Map的&quot;MapParam&quot;说明符、标识容器Set的&quot;SetParam&quot;说明符以及各种辅助说明符，四种说明符存在部分差异。 以下代码编译运行环境：UE4 v4.25 / vs2017 （1）Single Variable泛型参数的函数声明示例 public: // Wildcard property // Declare a function with an wildcard parameter. UFUNCTION(BlueprintCallable, CustomThunk, meta = (CustomStructureParam = &quot;Value&quot;), Category = &quot;Utilities|Variadic&quot;) static void PropertyFunction1(const int32&amp; Value); DECLARE_FUNCTION(execPropertyFunction1) {} // The variable marked by &quot;CustomStructureParam&quot; would be a placeholder. UFUNCTION(BlueprintCallable, CustomThunk, meta = (CustomStructureParam = &quot;Value&quot;), Category = &quot;Utilities|Variadic&quot;) static void PropertyFunction2(UProperty* Value); DECLARE_FUNCTION(execPropertyFunction2) {} // Declare a function with multiple wildcard parameters. UFUNCTION(BlueprintCallable, CustomThunk, meta = (CustomStructureParam = &quot;Value1,Value2,Value&quot;), Category = &quot;Utilities|Variadic&quot;) static void PropertyFunction3(const int32&amp; Value1, const int32&amp; Value2, int32&amp; Value); DECLARE_FUNCTION(execPropertyFunction3) {} // Declare a function with incorrect delimiter ---&gt; Bad case &lt;--- UFUNCTION(BlueprintCallable, CustomThunk, meta = (CustomStructureParam = &quot;Value1|Value2&quot;), Category = &quot;Utilities|Variadic&quot;) static void PropertyFunction4(const int32&amp; Value1, const int32&amp; Value2); DECLARE_FUNCTION(execPropertyFunction4) {} // Declare a function with one incorrect type ---&gt; Bad case &lt;--- UFUNCTION(BlueprintCallable, CustomThunk, meta = (CustomStructureParam = &quot;Value&quot;), Category = &quot;Utilities|Variadic&quot;) static void PropertyFunction5(const TArray&lt;int32&gt;&amp; Value); DECLARE_FUNCTION(execPropertyFunction5) {} 将以上代码拷贝到以UBlueprintFunctionLibrary为基类的C++类的头文件中（.h文件），编译后即可在蓝图系统中找到这5个蓝图节点。 图1. CustomStructureParam说明符声明的泛型蓝图节点； Single Variable泛型参数的函数声明规则 ： （1） UFUNTIION()宏应包含三类说明符：①表示蓝图可调用含义的说明符，如常用的BlueprintCallable、BlueprintPure；② CustomThunk说明符，标识该函数需要自定义Thunk函数体；③被CustomStructureParam说明符所标识的泛型参数列表，其他说明符视情形选择。（见示例PropertyFunction1 / PropertyFunction2 / PropertyFunction5） （2） 被CustomStructureParam说明符标识的函数参数实为一个占位符，源代码中常用const int32&amp; VariableName表示一个输入类型泛型参数，int32&amp; VariableName表示一个输出类型的泛型参数。（见示例 PropertyFunction3） （3） CustomStructureParam说明符标识多个泛型变量时，变量之间需以英文逗号”,”作为分隔符，不得包含其他字符，如空格 、”|”等其他字符；否则虽然可以通过vs编译，但是在蓝图系统不会如期显示。（见示例 PropertyFunction4） （4） 限制：目前，在源代码中并没有存在（或者说没发现）标识多个Single Variable泛型参数之间依赖关系的辅助说明符，也就是不能定义多个Single Variable 泛型参数彼此之间的依赖关系。 （2）Array泛型参数的蓝图函数声明示例 public: // Wildcard TArray // Declare a function with one wildcard array parameter. UFUNCTION(BlueprintCallable, CustomThunk, meta = (ArrayParm = &quot;Array&quot;), Category = &quot;Utilities|Variadic&quot;) static void ArrayFunction1(const TArray&lt;int32&gt;&amp; Array); DECLARE_FUNCTION(execArrayFunction1) {} // Declare a function with one wildcard array parameter with an type dependent parameter . UFUNCTION(BlueprintCallable, CustomThunk, meta = (ArrayParm = &quot;Array&quot;, ArrayTypeDependentParams = &quot;Item&quot;), Category = &quot;Utilities|Variadic&quot;) static void ArrayFunction2(const TArray&lt;int32&gt;&amp; Array, const int32&amp; Item); DECLARE_FUNCTION(execArrayFunction2) {} // Declare a function with multiple wildcard array parameters. UFUNCTION(BlueprintCallable, CustomThunk, meta = (ArrayParm = &quot;Array1,Array2,Array3&quot;, ArrayTypeDependentParams = &quot;Array1,Array2,Array3&quot;), Category = &quot;Utilities|Variadic&quot;) static void ArrayFunction3(const TArray&lt;int32&gt;&amp; Array1, const TArray&lt;int32&gt;&amp; Array2, TArray&lt;int32&gt;&amp; Array3); DECLARE_FUNCTION(execArrayFunction3) {} // Declare a function with multiple wildcard array parameters UFUNCTION(BlueprintCallable, CustomThunk, meta = (ArrayParm = &quot;Array1,Array2,Array3&quot;, ArrayTypeDependentParams = &quot;Array1,Array3&quot;), Category = &quot;Utilities|Variadic&quot;) static void ArrayFunction4(const TArray&lt;int32&gt;&amp; Array1, const TArray&lt;int32&gt;&amp; Array2, TArray&lt;int32&gt;&amp; Array3); DECLARE_FUNCTION(execArrayFunction4) {} // Declare a function with multiple wildcard array parameters. ---&gt; Bad case &lt;--- UFUNCTION(BlueprintCallable, CustomThunk, meta = (ArrayParm = &quot;Array1|Array2|Array3&quot;), Category = &quot;Utilities|Variadic&quot;) static void ArrayFunction5(const TArray&lt;int32&gt;&amp; Array1, const TArray&lt;int32&gt;&amp; Array2, TArray&lt;int32&gt;&amp; Array3); DECLARE_FUNCTION(execArrayFunction5) {} 图2. ArrayParm说明符声明的泛型蓝图节点； Wildcard Array泛型函数声明规则 ： （1） UFUNTIION()宏应包含三类说明符：①表示蓝图可调用含义的说明符，如常用的BlueprintCallable、BlueprintPure；② CustomThunk说明符，标识该函数需要自定义Thunk函数体；③被说明符ArrayParm所标识的泛型参数（wildcard array）列表，此外还可能包含标识泛型Array参数之间依赖关系的ArrayTypeDependentParams说明符，其他说明符视情形选择。（见示例 ArrayFunction1 / ArrayFunction2 / ArrayFunction3 / ArrayFunction4） （2） 源代码中常用const TArray&amp; ArrayName表示一个输入类型的泛型Array参数，TArray&amp; ArrayName表示一个输出类型的泛型Array参数。（见示例ArrayFunction3） （3） ArrayParm说明符标识多个泛型参数变量时，变量之间需以英文逗号”,”分隔，不得包含其他字符，否则虽然可以通过编译，但是在蓝图系统中显示异常。（见示例ArrayFunction5） （4） 被ArrayTypeDependentParams说明符标识的多个泛型Array参数的类型相互依赖，在蓝图图表中被调用时只有确定其中之一，余下泛型Array参数随之变化。 更多泛型Array示例见源码：KismetArrayLibrary.h （3）Map泛型参数的函数声明示例 public: // wildcard TMap // Declare a function with one wildcard array parameter. UFUNCTION(BlueprintCallable, CustomThunk, meta = (MapParam = &quot;TargetMap&quot;), Category = &quot;Utilities|Variadic&quot;) static void MapFunciton1(const TMap&lt;int32, int32&gt;&amp; TargetMap); DECLARE_FUNCTION(execMapFunciton1) {} // Declare a function with one wildcard map parameter with type dependent parameters. UFUNCTION(BlueprintCallable, CustomThunk, meta = (MapParam = &quot;TargetMap&quot;, MapKeyParam = &quot;Key&quot;, MapValueParam = &quot;Value&quot;, AutoCreateRefTerm = &quot;Key, Value&quot;), Category = &quot;Utilities|Variadic&quot;) static void MapFunciton2(const TMap&lt;int32, int32&gt;&amp; TargetMap, const int32&amp; Key, const int32&amp; Value); DECLARE_FUNCTION(execMapFunciton2) {} //UNSUPPORTED ---&gt; Declare a function with multiple wildcard map parameters. UFUNCTION(BlueprintCallable, CustomThunk, meta = (MapParam = &quot;TargetMap,SourceMap,ReturnMap&quot;), Category = &quot;Utilities|Variadic&quot;) static void MapFunciton3(const TMap&lt;int32, int32&gt;&amp; TargetMap, const TMap&lt;int32, int32&gt;&amp; SourceMap, TMap&lt;int32, int32&gt;&amp; ReturnMap); DECLARE_FUNCTION(execMapFunciton3) {} //UNSUPPORTED ---&gt; Declare a function with multiple wildcard map parameters. UFUNCTION(BlueprintCallable, CustomThunk, meta = (MapParam = &quot;TargetMap|SourceMap|ReturnMap&quot;), Category = &quot;Utilities|Variadic&quot;) static void MapFunciton4(const TMap&lt;int32, int32&gt;&amp; TargetMap, const TMap&lt;int32, int32&gt;&amp; SourceMap, TMap&lt;int32, int32&gt;&amp; ReturnMap); DECLARE_FUNCTION(execMapFunciton4) {} 图3. MapParm说明符声明的泛型蓝图节点； Wildcard Map泛型函数声明规则 ： （1） UFUNTIION()宏应包含三类说明符：①表示蓝图可调用含义的说明符，如常用的BlueprintCallable、BlueprintPure；② CustomThunk说明符，标识该函数需要自定义Thunk函数体；③被说明符MapParam所标识的泛型Map参数（wildcard map）列表，其他说明符视情形选择。（见示例 MapFunciton1 / MapFunciton2） （2） 源代码中常用const TMap&amp; MapName表示一个输入类型的泛型Map参数，TMap&amp; MapName表示一个输出类型的泛型Map参数。（见示例 MapFunciton4） （3） 经试验，声明多个泛型Map参数时无论是采用”,”还是”|”分隔变量，在蓝图系统均出现不同情形的异常情况；以逗号分隔多个泛型Map参数时，蓝图西并没有将这些参数标识为泛型Map引脚。”|”分隔多个参数时，虽然该蓝图节点显示为多个泛型Map引脚，但是当连接上Map类型变量时该引脚并没有更新类型，如上图示例MapFunciton3和 MapFunciton4。不确定这是不是一个引擎bug！？ （4） 被MapKeyParam和MapValueParam说明符标识的泛型参数与被MapParam说明符标识的泛型参数相互依赖。 Map没有类似于” ArrayTypeDependentParams”说明符一样标识多个泛型Map参数依赖关系的辅助说明符” MapTypeDependentParams”，（见示例MapFunciton2）。更多泛型Map示例见源码：BlueprintMapLibrary.h。 （4）Set泛型参数的函数声明示例 public:// wildcard Set // Declare a function with one wildcard Set parameter. UFUNCTION(BlueprintCallable, CustomThunk, meta = (SetParam = &quot;TargetSet&quot;), Category = &quot;Utilities|Variadic&quot;) static void SetFunciton1(const TSet&lt;int32&gt;&amp; TargetSet); DECLARE_FUNCTION(execSetFunciton1) {} // Declare a function with one wildcard Set parameter with type independent parameter. UFUNCTION(BlueprintCallable, CustomThunk, meta = (SetParam = &quot;TargetSet,NewItem&quot;), Category = &quot;Utilities|Variadic&quot;) static void SetFunciton2(const TSet&lt;int32&gt;&amp; TargetSet, const int32&amp; NewItem); DECLARE_FUNCTION(execSetFunciton2) {} // Declare a function with one wildcard Set parameter with type dependent parameter. UFUNCTION(BlueprintCallable, CustomThunk, meta = (SetParam = &quot;TargetSet|NewItem&quot;), Category = &quot;Utilities|Variadic&quot;) static void SetFunciton3(const TSet&lt;int32&gt;&amp; TargetSet, const int32&amp; NewItem); DECLARE_FUNCTION(execSetFunciton3) {} // Declare a function with one wildcard Set parameter and type dependent array parameter UFUNCTION(BlueprintCallable, CustomThunk, meta = (SetParam = &quot;TargetSet|NewItems&quot;), Category = &quot;Utilities|Variadic&quot;) static void SetFunciton4(const TSet&lt;int32&gt;&amp; TargetSet, const TArray&lt;int32&gt;&amp; NewItems); DECLARE_FUNCTION(execSetFunciton4) {} // Declare a function with multiple wildcard Set parameters v1 UFUNCTION(BlueprintCallable, CustomThunk, meta = (SetParam = &quot;Set1|Set2,Set3&quot;), Category = &quot;Utilities|Variadic&quot;) static void SetFunciton5(const TSet&lt;int32&gt;&amp; Set1, const TSet&lt;int32&gt;&amp; Set2, TSet&lt;int32&gt;&amp; Set3); DECLARE_FUNCTION(execSetFunciton5) {} // Declare a function with multiple wildcard Set parameters v2 UFUNCTION(BlueprintCallable, CustomThunk, meta = (SetParam = &quot;Set1|Set2|Set3&quot;), Category = &quot;Utilities|Variadic&quot;) static void SetFunciton6(const TSet&lt;int32&gt;&amp; Set1, const TSet&lt;int32&gt;&amp; Set2, TSet&lt;int32&gt;&amp; Set3); DECLARE_FUNCTION(execSetFunciton6) {} 图4. SetParm说明符声明的泛型蓝图节点； 声明规则 ： （1） UFUNTIION()宏应包含三类说明符：①表示蓝图可调用含义的说明符，如常用的BlueprintCallable、BlueprintPure；② CustomThunk说明符，标识该函数需要自定义Thunk函数体；③被说明符SetParam所标识的泛型Set参数（wildcard set）列表，其他说明符视情形选择，（见示例SetFunciton1 / SetFunciton2 / SetFunciton3）。 （2） 源代码中常用const TSet&amp; SetName表示一个输入类型的泛型Set参数，TSet&amp; SetName表示一个输出类型的泛型Set参数，（见示例SetFunciton1 / SetFunciton5）。 （3） 声明多个泛型Set参数时, SetParam说明符列表的泛型参数之间可以使用”,”和”|”二种分隔符，（见示例SetFunciton2 / SetFunciton3）；SetParam说明符同时也可以标识有依赖关系的泛型Arrary参数，（见示例SetFunciton4）。 （4） 多个泛型参数的依赖关系由分隔符的类型决定，以逗号”,”分隔的多个泛型Set参数之间相互独立，以”|”分隔的多个泛型Set参数之间相互依赖，（见示例SetFunciton5 / SetFunciton6）。更多泛型Set示例见源码：BlueprintSetLibrary.h 4.3 Thunk函数体的实现过程 如前所述，在UFUNCTION宏中使用了CustomThunk说明符，需要为该函数自定义Thunk函数体。Thunk函数体主要作用：当蓝图节点被调用时，获取从蓝图虚拟机VM中传递来的参数值，并将值传递给执行特定功能的c++函数。 首先了解下Thunk函数体的由来。通常定义在c++类中，并用UFUNCTION宏标识为蓝图可调用的函数；编译时，UHT会在该类的generated.h文件中为其自动生成一个形如DECLARE_FUNCTION(execFunctionName) {}的函数体，也就是我们所说的Thunk函数体。 举例来说，在BlueprintFunctionLibrary中声明如下函数 UFUNCTION(BlueprintPure, BlueprintCallable, Category = &quot;Math|Random&quot;, meta = (DisplayName = &quot;Random Character&quot;, Keywords = &quot;random, char，string&quot;)) static FString GetRandomCharacter(int32 MinValue = 33, int32 MaxValue = 126); generated.h文件中就存在如下代码块 DECLARE_FUNCTION(execGetRandomCharacter) \\ { \\ P_GET_PROPERTY(UIntProperty, Z_Param_MinValue); \\ P_GET_PROPERTY(UIntProperty, Z_Param_MaxValue); \\ P_FINISH; \\ P_NATIVE_BEGIN; \\ *(FString*)Z_Param__Result = URandomAlgorithm::GetRandomCharacter(Z_Param_MinValue, Z_Param_MaxValue); \\ P_NATIVE_END; \\ } 图5. 在generated.h文件中查找Thunk函数体； Thunk函数体有其特定的语法规则，要想自定义泛型蓝图节点，就必然要学会编写Thunk函数体。熟练掌握Thunk函数体的语法规则，就可以随心所欲的自定义Thunk函数体。Thunk函数体的用途在于Runtime时获取蓝图VM传递过来的参数值，因而Thunk函数的代码是在Runtime时运行的。在自定义Thunk函数体中所使用的宏定义于UObject\\ScriptMacros.h文件中。 自定义Thunk函数体包含如下规则： （1）Thunk函数的基本形式如下， DECLARE_FUNCTION(execFunctionName) {}，FucntionName为函数声明时的函数名称。在花括号{}内部包含的代码：P_FINISH宏之前为获取函数参数的代码块、P_NATIVE_BEGIN和P_NATIVE_END宏包裹着真正执行该函数功能的被调用函数，若是泛型蓝图节点，此处调用该函数的泛型版本（泛型函数）。若函数无返回值，可以直接调用泛型函数；若存在返回值，则应当在&quot;=&quot;左侧定义适当的返回值类型。 DECLARE_FUNCTION(execFunctionName) { // Get Parameters P_FINISH; P_NATIVE_BEGIN; *(FString*)Result = Generic_FunctionName(); // Call generic function P_NATIVE_END; } （2）当在Thunk函数体中获取多个参数时，获取的先后次序应与函数声明时变量在参数列表中出现的次序保持一致，否则在函数被调用时将引发程序崩溃。 （3）在Thunk函数体中，泛型蓝图函数的参数列表中确定类型的参数（如bool / uint8 / int32 / float / FName / FString等）和泛型参数（wilcard SingleVariable / TArray / TMap / TSet）获取方式不同。 a.获取确定类型的函数参数的代码的编写方法： 如下示例，可以先定义一个带该已知类型的函数，编译后在该类.generated.h文件中找到同名的Thunk体后，并定位到获取该类型参数的代码块。按同样的规则，在自定义的Thunk函数体中，编写获取该参数的代码即可，这种方式对于新手非常有用。 确定类型变量函数声明示例： UFUNCTION(BlueprintCallable, Category = &quot;MyProject&quot;) static void TestFunction( bool BoolVar , uint8 ByteVar , int32 IntegerVar , float FloatVar , FName NameVar , FString StringVar , const FText&amp; TextVar , FVector VectorVar , FTransform TransformVar , UObject* ObjectVar , TSubclassOf&lt;UObject&gt; ClassVar , bool&amp; RetBoolVar , uint8&amp; RetByteVar , int32&amp; RetIntegerVar , float&amp; RetFloatVar , FName&amp; RetNameVar , FString&amp; RetStringVar , FText&amp; RetTextVar , FVector&amp; RetVectorVar , FTransform&amp; RetTransformVar , UObject*&amp; RetObjectVar , TSubclassOf&lt;UObject&gt;&amp; RetClassVar ) ; 对应的自动生成的Thunk函数体示例： DECLARE_FUNCTION(execTestFunction) \\ { \\ P_GET_UBOOL(Z_Param_BoolVar); \\ P_GET_PROPERTY(UByteProperty, Z_Param_ByteVar); \\ P_GET_PROPERTY(UIntProperty, Z_Param_IntegerVar); \\ P_GET_PROPERTY(UFloatProperty, Z_Param_FloatVar); \\ P_GET_PROPERTY(UNameProperty, Z_Param_NameVar); \\ P_GET_PROPERTY(UStrProperty, Z_Param_StringVar); \\ P_GET_PROPERTY_REF(UTextProperty, Z_Param_Out_TextVar); \\ P_GET_STRUCT(FVector, Z_Param_VectorVar); \\ P_GET_STRUCT(FTransform, Z_Param_TransformVar); \\ P_GET_OBJECT(UObject, Z_Param_ObjectVar); \\ P_GET_OBJECT(UClass, Z_Param_ClassVar); \\ P_GET_UBOOL_REF(Z_Param_Out_RetBoolVar); \\ P_GET_PROPERTY_REF(UByteProperty, Z_Param_Out_RetByteVar); \\ P_GET_PROPERTY_REF(UIntProperty, Z_Param_Out_RetIntegerVar); \\ P_GET_PROPERTY_REF(UFloatProperty, Z_Param_Out_RetFloatVar); \\ P_GET_PROPERTY_REF(UNameProperty, Z_Param_Out_RetNameVar); \\ P_GET_PROPERTY_REF(UStrProperty, Z_Param_Out_RetStringVar); \\ P_GET_PROPERTY_REF(UTextProperty, Z_Param_Out_RetTextVar); \\ P_GET_STRUCT_REF(FVector, Z_Param_Out_RetVectorVar); \\ P_GET_STRUCT_REF(FTransform, Z_Param_Out_RetTransformVar); \\ P_GET_OBJECT_REF(UObject, Z_Param_Out_RetObjectVar); \\ P_GET_OBJECT_REF_NO_PTR(TSubclassOf&lt;UObject&gt;, Z_Param_Out_RetClassVar); \\ P_FINISH; \\ P_NATIVE_BEGIN; \\ UMiscAlgorithm::TestFunction(Z_Param_BoolVar, Z_Param_ByteVar, Z_Param_IntegerVar, Z_Param_FloatVar, Z_Param_NameVar, Z_Param_StringVar, Z_Param_Out_TextVar, Z_Param_VectorVar, Z_Param_TransformVar, Z_Param_ObjectVar, Z_Param_ClassVar, Z_Param_Out_RetBoolVar, Z_Param_Out_RetByteVar, Z_Param_Out_RetIntegerVar, Z_Param_Out_RetFloatVar, Z_Param_Out_RetNameVar, Z_Param_Out_RetStringVar, Z_Param_Out_RetTextVar, Z_Param_Out_RetVectorVar, Z_Param_Out_RetTransformVar, Z_Param_Out_RetObjectVar, Z_Param_Out_RetClassVar); \\ P_NATIVE_END; \\ } \\ b.获取泛型参数的代码的编写方法： ue4 v4.25以上版本 UProperty已被FProperty替代，本质没变，只需稍作修改。以下代码为4.25之前版本。获取泛型参数需要同时获取该变量地址void和变量属性UProperty/ UArrayProperty* / UMapProperty* / USetProperty*，如下示例： 获取泛型Single Variable Stack.StepCompiledIn&lt;UStructProperty&gt;(NULL); void* SrcPropertyAddr = Stack.MostRecentPropertyAddress; UProperty* SrcProperty = Cast&lt;UProperty&gt;(Stack.MostRecentProperty); 获取泛型Array Variable Stack.StepCompiledIn&lt;UArrayProperty&gt;(NULL); void* SrcArrayAddr = Stack.MostRecentPropertyAddress; UArrayProperty* SrcArrayProperty = Cast&lt;UArrayProperty&gt;(Stack.MostRecentProperty); 获取泛型Map Variable Stack.MostRecentProperty = nullptr; Stack.StepCompiledIn&lt;UMapProperty&gt;(NULL); void* SrcMapAddr = Stack.MostRecentPropertyAddress; UMapProperty* SrcMapProperty = Cast&lt;UMapProperty&gt;(Stack.MostRecentProperty); 获取泛型Set Variable Stack.MostRecentProperty = nullptr; Stack.StepCompiledIn&lt;USetProperty&gt;(NULL); void* SetAddr = Stack.MostRecentPropertyAddress; USetProperty* SetProperty = Cast&lt;USetProperty&gt;(Stack.MostRecentProperty); 5. Conclusion 以上内容讲述了泛型蓝图节点的三个组成部分的主要功能，以及带泛型参数蓝图节点的声明方法和自定义Thunk函数体的实现过程。为避免文章过长，在下一节 UE4 基于CustomThunk的泛型蓝图节点语法规范 (二)， 将分享几个自己编写的泛型蓝图节点**，**让大家对自定义泛型蓝图节点的第三部分-泛型函数（Generic）有加全面而清晰认识。 ","link":"https://xusjtuer.github.io/post/ue4-post4_generic_bluerpint_function_customthunk1/"},{"title":"UE4 泛型蓝图节点的实现及应用实例","content":"1. Overview 本教程旨在讲解使用ue4 UFUNCTION说明符（Specifier）自定义泛型蓝图节点，实现UObject的任意类型属性（UProperty）GET/SET方法。如下四个泛型蓝图节点，依据UObject对象的PropertyName，GET/SET属性值，适用于v4.25之前版本。 图1. 泛型蓝图节点； 2. Introduction 泛型蓝图节点也就是带有可变参数的蓝图节点，通用指蓝图系统中带有通配符（wildcard）类型参数的蓝图节点。实现泛型蓝图节点至少有二种方式，其一，继承UK2Node类，并根据需要实现其派生类，如常用的Cast节点，Set By-Ref Var节点等都属于此类；其二，使用UFUNCTION中CustomThunk说明符以及相应的类型说明符标识wildcard参数，并为该蓝图函数自定义DECLARE_FUNCTION()函数体，如Utilities|Array，Utilities|Map，Utilities|Set 目录下，三种容器Array、Map、Set各类操作的蓝图节点都属于此类。此外ue4内置的蓝图节点还存在着将二者结合的蓝图节点GetDataTableRow，UK2Node_GetDataTableRow类(基类UK2Node)在Editor状态下动态更新Pin，UDataTableFunctionLibrary类中GetDataTableRowFromName函数在Runtime状态下，执行具体的GetDataTableRowFromName方法，将DataTable中的RowStruct拷贝到OutRowStruct。以上二种方式各有其优缺点，本次讲解采用代码量少、实现难度低的第二种方式。 3. Required Knowledge 熟悉UE4 C++ UFUNCTION宏常用关键字， 自定义execFunction函数体;（预计下一讲） 4. Why 第1个问题：为什么要实现这样一类节点？ 目的：（1）提升自身的编程水平，加深个人对于泛型蓝图节点的理解；（2）减少蓝图之间的引用，提升蓝图执行性能。 如下图所示，从BP_Actor蓝图（基类Actor）中获取ThirdPersonCharacter蓝图的Health属性，左边是一种常见的方式(使用Cast节点)，右边则是使用一个自定义实现的泛型蓝图节点GET/SET节点。二种获取Character属性的方法对BP_Actor的影响却显著不同，使用Cast节点增加了BP_Actor的引用，使得SizeMap暴增，显著影响性能（附：把属性（Property）定义在c++基类，Cast to c++类，也可以获得到蓝图的该属性，同时也可以使二个蓝图的引用断开）。 图2. 二种获取UProperty值得方法； 那么断开二个蓝图的引用有什么好处？ue4 中c++和蓝图除了广为人知的效率差异，另外一个重要区别在于内存和加载（Memory and Loading）方式差异，蓝图引用增多可能导致内存消耗变大以及加载时间变长（详情见虚幻引擎官方视频，[FestEurope2019] 蓝图深入探讨 | Blueprints In-depth，因此减少蓝图之间相互引用对于提升性能有着关键的作用。 回到主题，在ue4中实现泛型蓝图节点，获取UObject的任意属性。如下图示例，以获取UProperty属性为例，根据变量名PropertyName获取Target（ActorBP）获取属性Value，并将获取到的属性值保存在This变量中，获取不同类型（bool、Byte、integer、float、String、Name、Vector、Rotator、Transform、任意UStruct）的属性都是使用同一个节点。 图3. 泛型蓝图节点GET/SET使用示例； 图4. 输出日志LOG； LogBlueprintUserMessages: [BP_Actor_2] Tooltip -&gt; Before GET ,This Bool-&gt; false ,This Byte-&gt; 0 ,This Integer-&gt; 0 ,This Float-&gt; 0.0 ,This String-&gt; ,This Transform-&gt; Translation: X=0.000 Y=0.000 Z=0.000 Rotation: P=0.000000 Y=0.000000 R=0.000000 Scale X=1.000 Y=1.000 Z=1.000 ,This Struct-&gt; {&quot;B&quot;: 0, &quot;G&quot;: 0, &quot;R&quot;: 0, &quot;A&quot;: 0} LogBlueprintUserMessages: [BP_Actor_2] Tooltip -&gt; After GET ,This Bool-&gt; true ,This Byte-&gt; 10 ,This Integer-&gt; 10 ,This Float-&gt; 15.0 ,This String-&gt; Unreal Engine ,This Transform-&gt; Translation: X=70.000 Y=80.000 Z=90.000 Rotation: P=69.999931 Y=120.000008 R=-79.999908 Scale X=0.100 Y=0.200 Z=0.300 ,This Struct-&gt; {&quot;B&quot;: 156, &quot;G&quot;: 253, &quot;R&quot;: 255, &quot;A&quot;: 1} 第2个问题：为什么能实现一个这样的节点？ UObject对象支持根据属性名（PropertyName）查找属性（UProperty），然后可以取得PropertyValue。因此基于PropertyName获取UObject PropertyValue是理论可行的，并且ue4源码KismetSystemLibray类中已经向我们展示一些UObject对象不同类型（int32 / uint8 / float / bool等等）属性的Set Property by name 函数的实现方式，但是这些函数仅供蓝图内部使用。 // --- 'Set property by name' functions ------------------------------ /** Set an int32 property by name */ UFUNCTION(BlueprintCallable, meta=(BlueprintInternalUseOnly = &quot;true&quot;)) static void SetIntPropertyByName(UObject* Object, FName PropertyName, int32 Value); /** Set an int64 property by name */ UFUNCTION(BlueprintCallable, meta=(BlueprintInternalUseOnly = &quot;true&quot;)) static void SetInt64PropertyByName(UObject* Object, FName PropertyName, int64 Value); /** Set an uint8 or enum property by name */ UFUNCTION(BlueprintCallable, meta=(BlueprintInternalUseOnly = &quot;true&quot;)) static void SetBytePropertyByName(UObject* Object, FName PropertyName, uint8 Value); /** Set a float property by name */ UFUNCTION(BlueprintCallable, meta=(BlueprintInternalUseOnly = &quot;true&quot;)) static void SetFloatPropertyByName(UObject* Object, FName PropertyName, float Value); /** Set a bool property by name */ UFUNCTION(BlueprintCallable, meta=(BlueprintInternalUseOnly = &quot;true&quot;)) static void SetBoolPropertyByName(UObject* Object, FName PropertyName, bool Value); /** Set an OBJECT property by name */ UFUNCTION(BlueprintCallable, meta=(BlueprintInternalUseOnly = &quot;true&quot;)) static void SetObjectPropertyByName(UObject* Object, FName PropertyName, UObject* Value); /** Set a CLASS property by name */ UFUNCTION(BlueprintCallable, meta = (BlueprintInternalUseOnly = &quot;true&quot;)) static void SetClassPropertyByName(UObject* Object, FName PropertyName, TSubclassOf&lt;UObject&gt; Value); /** Set an INTERFACE property by name */ UFUNCTION(BlueprintCallable, Category = &quot;Collision&quot;, meta = (BlueprintInternalUseOnly = &quot;true&quot;)) static void SetInterfacePropertyByName(UObject* Object, FName PropertyName, const FScriptInterface&amp; Value); /** Set a NAME property by name */ UFUNCTION(BlueprintCallable, meta=(BlueprintInternalUseOnly = &quot;true&quot;, AutoCreateRefTerm = &quot;Value&quot; )) static void SetNamePropertyByName(UObject* Object, FName PropertyName, const FName&amp; Value); /** Set a SOFTOBJECT property by name */ UFUNCTION(BlueprintCallable, meta = (BlueprintInternalUseOnly = &quot;true&quot;, AutoCreateRefTerm = &quot;Value&quot;)) static void SetSoftObjectPropertyByName(UObject* Object, FName PropertyName, const TSoftObjectPtr&lt;UObject&gt;&amp; Value); /** Set a SOFTCLASS property by name */ UFUNCTION(BlueprintCallable, meta = (BlueprintInternalUseOnly = &quot;true&quot;, AutoCreateRefTerm = &quot;Value&quot;)) static void SetSoftClassPropertyByName(UObject* Object, FName PropertyName, const TSoftClassPtr&lt;UObject&gt;&amp; Value); /** Set a STRING property by name */ UFUNCTION(BlueprintCallable, meta=(BlueprintInternalUseOnly = &quot;true&quot;, AutoCreateRefTerm = &quot;Value&quot; )) static void SetStringPropertyByName(UObject* Object, FName PropertyName, const FString&amp; Value); /** Set a TEXT property by name */ UFUNCTION(BlueprintCallable, meta=(BlueprintInternalUseOnly = &quot;true&quot;, AutoCreateRefTerm = &quot;Value&quot; )) static void SetTextPropertyByName(UObject* Object, FName PropertyName, const FText&amp; Value); /** Set a VECTOR property by name */ UFUNCTION(BlueprintCallable, meta=(BlueprintInternalUseOnly = &quot;true&quot;, AutoCreateRefTerm = &quot;Value&quot; )) static void SetVectorPropertyByName(UObject* Object, FName PropertyName, const FVector&amp; Value); /** Set a ROTATOR property by name */ UFUNCTION(BlueprintCallable, meta=(BlueprintInternalUseOnly = &quot;true&quot;, AutoCreateRefTerm = &quot;Value&quot; )) static void SetRotatorPropertyByName(UObject* Object, FName PropertyName, const FRotator&amp; Value); /** Set a LINEAR COLOR property by name */ UFUNCTION(BlueprintCallable, meta=(BlueprintInternalUseOnly = &quot;true&quot;, AutoCreateRefTerm = &quot;Value&quot; )) static void SetLinearColorPropertyByName(UObject* Object, FName PropertyName, const FLinearColor&amp; Value); /** Set a TRANSFORM property by name */ UFUNCTION(BlueprintCallable, meta=(BlueprintInternalUseOnly = &quot;true&quot;, AutoCreateRefTerm = &quot;Value&quot; )) static void SetTransformPropertyByName(UObject* Object, FName PropertyName, const FTransform&amp; Value); 源代码中SetPropertyByName函数； 每一种类型Property都有二个基本属性，PropertyAddress（void*）和Property Size。而GET方法的本质上可以描述为：在获取UObject的属性(Property)后，将该属性所指向内存区域的值拷贝到返回值变量的内存区域，即返回值变量获取到Object-&gt;Property Value；SET方法则是逆过程，同样在找到Object的属性后，将输入值变量所指向内存区域的值拷贝到Object的相应属性指向的内存区域。 不同类型的Property除了内存地址不一样，所占用的内存空间大小也不一样，只有保证内存空间一样，也就是同一类属性才可以相互复制而不至于引起程序崩溃。对于派生于UProperty类的类型，如UBoolProerty / UEnumProperty / UNumericProperty / UStructProperty等都可以直接用UProperty*指示Property占用内存空间的大小。派生于TProperty类的类型，如UArrayProperty / UMapProperty / USetProperty， 则需要分别使用UArrayProperty* / UMapProperty* / USetProperty*来表示内存空间大小。 仿照源代码KismetSystemLibray类中Set Property by Name 函数，明显可以得出我们的泛型蓝图节点的引脚（PIN）参数应该按如下设计： GET节点： 输入参数：UObjct* Object 输入参数：FName PropertyName 输出参数：void* Value SET节点： 输入参数：UObjct* Object 输入参数：FName PropertyName 输入参数：void* Value 进一步分析以上设计存在二个问题： 其一： GET方法，仅传入Object和PropertyName，在编译阶段传入的Object Class可能并没有名为PropertyName的属性，故而无法确定返回值的类型，也就没法正确编译。因此需要在输入参数列表中添加一个指示返回值类型的输入参数。为了使用的方便，不妨直接将这个参数表示成void*类型，那么该参数不仅可以标识返回值类型，而且还可用来存储返回结果。综上：修改后的GET方法和SET方法形式上将会完全相同。 其二, 蓝图函数（BlueprintCallable），不支持void类型参数 如下示例代码： UFUNCTION(BlueprintCallable, Category = &quot;MyProject&quot;) void FunctionName(void* Variable); 编译报错 error : Unrecognized type 'void' - type must be a UCLASS, USTRUCT or UENUM 解决方法： UFUNCTION(BlueprintCallable, CustomThunk, meta = (CustomStructureParam = &quot;Variable&quot;, AutoCreateRefTerm = &quot;Variable&quot;), Category = &quot;MyProject&quot;) void FunctionName(const int32&amp; Variable); DECLARE_FUNCTION(execFunctionName) { } 修改后的方法： 其中CustomThunk的作用是指示UHT不需要为蓝图函数生成exec方法，使用自定义的execFunction，如上所示的 DECLARE_FUNCTION(execFunctionName) { } 其中，CustomStructureParam = &quot;Variable&quot;标识变量Variable为wildcard类型参数，“const int32&amp; Variable”并非表示Variable变量类型为const int32，该参数在此处相当于一个占位符，const + &amp; 指示该参数为输入参数；当然将int32替换成其他类型，也可以编译成功，此处为了与源代码保持一致。编译完成之后，可以在蓝图系统中找到如下节点： 图5. 泛型蓝图节点示例； 5. Approach 以UBlueprintFunctionLibrary为基类，创建C++类，头文件（.h） (附：为了减少文章中的显示长度（知乎代码块不支持折叠），以下仅列举其中一个蓝图节点实现代码，完整代码见：https://github.com/xusjtuer/NoteUE4) //（1）声明泛型函数，在蓝图系统中产生了一个带Wildcard参数的蓝图节点（.h文件）： /** * Get or Set object PROPERTY value by property name * * @param Object, object that owns this PROPERTY * @param PropertyName, property name * @param Value(return), save returned object property(Get Operation) as well as indicate property type * @param bSetter, If true, write Value to object property(Set operation). Otherwise, read object property and assign it to Value(Get operation) */ UFUNCTION(BlueprintCallable, CustomThunk, Category = &quot;Utilities|Variables&quot;, meta = (CustomStructureParam = &quot;Value&quot;, AutoCreateRefTerm = &quot;Value&quot;, DisplayName = &quot;GET/SET (Property)&quot;, CompactNodeTitle = &quot;GET/SET&quot;)) static void AccessPropertyByName(UObject* Object, FName PropertyName, const int32&amp; Value, bool bSetter = true); // （2）自定义CustomThunk 函数体，实现从蓝图VM中获取输入参数值（.h文件） DECLARE_FUNCTION(execAccessPropertyByName) { P_GET_OBJECT(UObject, OwnerObject); P_GET_PROPERTY(UNameProperty, PropertyName); Stack.StepCompiledIn&lt;UStructProperty&gt;(NULL); void* SrcPropertyAddr = Stack.MostRecentPropertyAddress; /// Reference: Plugins\\Experimental\\StructBox\\Source\\StructBox\\Classes\\StructBoxLibrary.h -&gt; execSetStructInBox UProperty* SrcProperty = Cast&lt;UProperty&gt;(Stack.MostRecentProperty); P_GET_UBOOL(bSetter); P_FINISH; P_NATIVE_BEGIN; Generic_AccessPropertyByName(OwnerObject, PropertyName, SrcPropertyAddr, SrcProperty, bSetter); P_NATIVE_END; } // （3）声明实际执行GET/SET过程的函数（.h文件） public: // Generic function // Get or set a UPROPERTY of UObject by property name static void Generic_AccessPropertyByName(UObject* OwnerObject, FName PropertyName, void* SrcPropertyAddr, UProperty* SrcProperty, bool bSetter = true); // （4）实现Generic函数（.cpp文件） void UParserPropertyLibrary::Generic_AccessPropertyByName(UObject* OwnerObject, FName PropertyName, void* SrcPropertyAddr, UProperty* SrcProperty, bool bSetter /*= true*/) { if (OwnerObject != NULL) { UProperty* FoundProp = FindField&lt;UProperty&gt;(OwnerObject-&gt;GetClass(), PropertyName); if ((FoundProp != NULL) &amp;&amp; (FoundProp-&gt;SameType(SrcProperty))) { void* Dest = FoundProp-&gt;ContainerPtrToValuePtr&lt;void&gt;(OwnerObject); if (bSetter == true) { FoundProp-&gt;CopySingleValue(Dest, SrcPropertyAddr); } else { FoundProp-&gt;CopySingleValue(SrcPropertyAddr, Dest); } return; } } UE_LOG(LogParserPropertyLibrary, Warning, TEXT(&quot;UParserPropertyLibrary::Generic_AccessPropertyByName: Failed to find %s variable from %s object&quot;), *PropertyName.ToString(), *UKismetSystemLibrary::GetDisplayName(OwnerObject)); } 6. Conclusion 本文主要介绍了自定义泛型蓝图节点的实现以及它的应用实例，实现了对UObject对象的任意属性的GET/SET方法，依据PropertyName，GET/SET UObject对象的属性UProperty。拓展：（1）将bSetter参数替换成操作符枚举，可以进一步扩充该泛型蓝图节点的应用，感兴趣的可以自己尝试。（2）是否可以将四个节点合并成一个节点。 ","link":"https://xusjtuer.github.io/post/ue4-post3_generic_get_set_object_property/"},{"title":"UE4 C++实现任意类型数组蓝图排序节点（Quick Sort）","content":"1. Overview 本教程旨在讲解在虚幻引擎(UE4) C++中实现蓝图(Blueprint)可调用的任意类型数组排序的蓝图节点。纯蓝图方法实现任意类型数组排序方法，请查看上一期 UE4 蓝图实现任意类型数组排序。以下泛型数组排序节点Array_Sort基于快速排序算法（Quick Sort）原理，冒泡排序（Bubble Sort）版见知乎链接：第2期 UE4 C++实现任意类型数组蓝图排序节点。编者水平有限，如有错漏敬请谅解。 2. Introduction 快速排序（Quick Sort）的平均时间复杂度为O(nlog2n)，冒泡排序（Bubble Sort）的平均时间复杂度为O(n2)，若以时间复杂度作为评价二种排序算法的优劣标准的话，快速排序明显优于冒泡排序。所以在已经介绍了冒泡版泛型数组排序方法，再次补充一个快速排序版泛型数组排序方法。同样地，以Sort by Function和Sort by Property作为比较数组成员大小的二种方式，分别编写了Sort Array by Function和Sort Array by Proerty二个泛型数组排序节点。 本文主要讲解UE4 C++泛型数组的快速排序蓝图节点的实现方法，以及该泛型快排节点与STL 排序方法的比较。 3. Sort Approach 3.1 基于SortBy Function，实现泛型数组排序 (1) h文件，Array_Sort函数声明： /** Generic sort array by function using quick sort algorithm. * * @param Array Target array to sort * @param Object The owner of CompareBy function,(DefaultToSelf) * @param SortBy Function name of overloads operator &quot;&lt;&quot; function The signature of the comparison function should be equivalent to the following: bool cmp(const Type1 &amp;a, const Type2 &amp;b); return value should named &quot;ReturnValue&quot;(bool) */ UFUNCTION(BlueprintCallable, CustomThunk, meta = (DisplayName = &quot;Sort Array by Function&quot;, CompactNodeTitle = &quot;Sort&quot;, ArrayParm = &quot;Array&quot;, AutoCreateRefTerm = &quot;Array&quot;, DefaultToSelf = &quot;Object&quot;, AdvancedDisplay = &quot;Object&quot;), Category = &quot;Utilities|Array&quot;) static void Array_SortV1(const TArray&lt;int32&gt;&amp; Array, UObject* Object, FName SortBy); // generic quick sort array by function name static void GenericArray_SortByFunction(UObject* OwnerObject, UFunction* ComparedBy, void* TargetArray, UArrayProperty* ArrayProp); // Low --&gt; Starting index, High --&gt; Ending index static void QuickSortByFunction_Recursive(UObject* OwnerObject, UFunction* ComparedBy, UProperty* InnerProp, FScriptArrayHelper&amp; ArrayHelper, int32 Low, int32 High); // swapping items in place and partitioning the section of an array static int32 QuickSortByFunction_Partition(UObject* OwnerObject, UFunction* ComparedBy, UProperty* InnerProp, FScriptArrayHelper&amp; ArrayHelper, int32 Low, int32 High); // Check that the CompareBy function is appropriate static bool IsSuitableFunction(UFunction* ComparedBy, UArrayProperty* ArrayProp); (2) h文件，Array_SortV1函数的自定义CustomThunk函数体 // sort array by function name DECLARE_FUNCTION(execArray_SortV1) { Stack.MostRecentProperty = nullptr; Stack.StepCompiledIn&lt;UArrayProperty&gt;(NULL); void* ArrayAAddr = Stack.MostRecentPropertyAddress; UArrayProperty* ArrayProperty = Cast&lt;UArrayProperty&gt;(Stack.MostRecentProperty); if (!ArrayProperty) { Stack.bArrayContextFailed = true; return; } P_GET_OBJECT(UObject, OwnerObject); P_GET_PROPERTY(UNameProperty, SortBy); if (!OwnerObject) { return; } UFunction* const SortFunction = OwnerObject-&gt;FindFunction(SortBy); if ((!SortFunction || (SortFunction-&gt;NumParms != 3))) { return; } P_FINISH; P_NATIVE_BEGIN; GenericArray_SortByFunction(OwnerObject, SortFunction, ArrayAAddr, ArrayProperty); P_NATIVE_END; } (3) cpp文件，GenericArray_SortByFunction()函数体 void UGenericArrayLibrary::GenericArray_SortByFunction(UObject* OwnerObject, UFunction* ComparedBy, void* TargetArray, UArrayProperty* ArrayProp) { if (!ComparedBy || !OwnerObject || !TargetArray) { return; } else if (!IsSuitableFunction(ComparedBy, ArrayProp)) { return; } // Optimal UKismetArrayLibrary::GenericArray_Shuffle(TargetArray, ArrayProp); // Begin sort array FScriptArrayHelper ArrayHelper(ArrayProp, TargetArray); if (ArrayHelper.Num() &lt; 2) { return; } else { UProperty* InnerProp = ArrayProp-&gt;Inner; QuickSortByFunction_Recursive(OwnerObject, ComparedBy, InnerProp, ArrayHelper, 0, ArrayHelper.Num() - 1); } } 其中，快排算法优化： // Optimal UKismetArrayLibrary::GenericArray_Shuffle(TargetArray, ArrayProp); (4) cpp文件，快排递归循环 void UGenericArrayLibrary::QuickSortByFunction_Recursive(UObject* OwnerObject, UFunction* ComparedBy, UProperty* InnerProp, FScriptArrayHelper&amp; ArrayHelper, int32 Low, int32 High) { if (Low &lt; High) { int32 Pivot = QuickSortByFunction_Partition(OwnerObject, ComparedBy, InnerProp, ArrayHelper, Low, High); QuickSortByFunction_Recursive(OwnerObject, ComparedBy, InnerProp, ArrayHelper, Low, Pivot - 1); QuickSortByFunction_Recursive(OwnerObject, ComparedBy, InnerProp, ArrayHelper, Pivot + 1, High); } } (5) cpp文件，快排拆分 int32 UGenericArrayLibrary::QuickSortByFunction_Partition(UObject* OwnerObject, UFunction* ComparedBy, UProperty* InnerProp, FScriptArrayHelper&amp; ArrayHelper, int32 Low, int32 High) { const int32 PropertySize = InnerProp-&gt;ElementSize * InnerProp-&gt;ArrayDim; UBoolProperty* ReturnProp = Cast&lt;UBoolProperty&gt;(ComparedBy-&gt;GetReturnProperty()); // CompareBy function parameters address, 2 input parameter(array item) and 1 return parameter (bool) uint8* FuncParamsAddr = (uint8*)FMemory::Malloc(ComparedBy-&gt;ParmsSize); /// note:ParamsSize = PropertySize* 2 +1 FMemory::Memzero(FuncParamsAddr, ComparedBy-&gt;ParmsSize); /** Based on quick sort of stl */ InnerProp-&gt;CopyCompleteValueFromScriptVM(FuncParamsAddr, ArrayHelper.GetRawPtr(High)); //Params1: LastSmallElem = Array[High] int32 i = Low - 1; for (int32 j = Low; j &lt; High; j++) { InnerProp-&gt;CopyCompleteValueFromScriptVM(FuncParamsAddr + PropertySize, ArrayHelper.GetRawPtr(j)); // Param2: Array[i] OwnerObject-&gt;ProcessEvent(ComparedBy, FuncParamsAddr); if (ReturnProp &amp;&amp; ReturnProp-&gt;GetPropertyValue(FuncParamsAddr + PropertySize * 2)) { i++; ArrayHelper.SwapValues(i, j); } } ArrayHelper.SwapValues(i + 1, High); // release memory FMemory::Free(FuncParamsAddr); return i + 1; } (6) cpp文件，判断用于比较数组元素大小的蓝图函数是否合乎要求 bool UGenericArrayLibrary::IsSuitableFunction(UFunction* ComparedBy, UArrayProperty* ArrayProp) { // check CompareBy function's parameter number if ((!ComparedBy || (ComparedBy-&gt;NumParms != 3))) { UE_LOG(LogTemp, Warning, TEXT(&quot;IsSuitableFunction -&gt; CompareBy function should only have 3 parameters !&quot;)); return false; } //Get return property of CompareBy function. UBoolProperty* ReturnProp = Cast&lt;UBoolProperty&gt;(ComparedBy-&gt;GetReturnProperty()); if (!ReturnProp) { /// The return Property of max function must be bool and named &quot;ReturnValue&quot; UE_LOG(LogTemp, Warning, TEXT(&quot;IsSuitableFunction -&gt; Return value of CompareBy function should be bool type, and named ReturnValue.&quot;)); return false; } // Get all parameters of CompareBy function TArray&lt;UProperty*&gt; ParamterList; for (TFieldIterator&lt;UProperty&gt; It(ComparedBy); It; ++It) { UProperty* FuncParameter = *It; ParamterList.Emplace(FuncParameter); } // Make sure the first/second input parameters of Compare function is same to array inner if (!ParamterList[0]-&gt;SameType(ArrayProp-&gt;Inner) || !ParamterList[1]-&gt;SameType(ArrayProp-&gt;Inner)) { /// The property of 1st input parameter of max function must be same as array member UE_LOG(LogTemp, Warning, TEXT(&quot;IsSuitableFunction -&gt; The parameters type of CompareBy should be same to array member.&quot;)); return false; } return true; } 3.2 基于SortBy Property，实现泛型数组排序 (1) h文件，Array_Sort函数声明： /** Generic sort array by property using quick sort algorithm. * * @param Array Target array to sort * @param PropertyName Name is the variable to sort by for struct or object array. Otherwise, the parameter is ignored. * @param bAscending If true, sort by ascending order. */ UFUNCTION(BlueprintCallable, CustomThunk, meta = (DisplayName = &quot;Sort Array by Property&quot;, CompactNodeTitle = &quot;Sort&quot;, ArrayParm = &quot;Array&quot;, AutoCreateRefTerm = &quot;Array&quot;, bAscending = &quot;true&quot;), Category = &quot;Utilities|Array&quot;) static void Array_SortV2(const TArray&lt;int32&gt;&amp; Array, FName PropertyName, bool bAscending); // generic quick sort array by property static void GenericArray_SortV2(void* TargetArray, UArrayProperty* ArrayProp, FName PropertyName, bool bAscending); // Low --&gt; Starting index, High --&gt; Ending index static void QuickSort_RecursiveByProperty(FScriptArrayHelper&amp; ArrayHelper, UProperty* InnerProp, UProperty* SortProp, int32 Low, int32 High, bool bAscending); // swapping items in place and partitioning the section of an array static int32 QuickSort_PartitionByProperty(FScriptArrayHelper&amp; ArrayHelper, UProperty* InnerProp, UProperty* SortProp, int32 Low, int32 High, bool bAscending); // generic compare two element of array by property static bool GenericComparePropertyValue(FScriptArrayHelper&amp; ArrayHelper, UProperty* InnerProp, UProperty* SortProp, int32 j, int32 High, bool bAscending); (2) h文件，Array_SortV2函数的自定义CustomThunk函数体 // sort array by property DECLARE_FUNCTION(execArray_SortV2) { Stack.MostRecentProperty = nullptr; Stack.StepCompiledIn&lt;UArrayProperty&gt;(NULL); void* ArrayAddr = Stack.MostRecentPropertyAddress; UArrayProperty* ArrayProperty = Cast&lt;UArrayProperty&gt;(Stack.MostRecentProperty); if (!ArrayProperty) { Stack.bArrayContextFailed = true; return; } P_GET_PROPERTY(UNameProperty, PropertyName); P_GET_UBOOL(bAscending); P_FINISH; P_NATIVE_BEGIN; GenericArray_SortV2(ArrayAddr, ArrayProperty, PropertyName, bAscending); P_NATIVE_END; } (3) cpp文件，GenericArray_SortV2()函数体 void UGenericArrayLibrary::GenericArray_SortV2(void* TargetArray, UArrayProperty* ArrayProp, FName PropertyName, bool bAscending) { if (!TargetArray) { return; } // Optimal UKismetArrayLibrary::GenericArray_Shuffle(TargetArray, ArrayProp); FScriptArrayHelper ArrayHelper(ArrayProp, TargetArray); UProperty* SortProperty = nullptr; if (ArrayHelper.Num() &lt; 2) { return; } else if (const UObjectProperty* ObjectProperty = Cast&lt;const UObjectProperty&gt;(ArrayProp-&gt;Inner)) { SortProperty = FindField&lt;UProperty&gt;(ObjectProperty-&gt;PropertyClass, PropertyName); } else if (const UStructProperty* StructProperty = Cast&lt;const UStructProperty&gt;(ArrayProp-&gt;Inner)) { SortProperty = SortAlgorithm::FindField&lt;UProperty&gt;(StructProperty-&gt;Struct, PropertyName); } else { SortProperty = ArrayProp-&gt;Inner; } if (SortProperty) { QuickSort_RecursiveByProperty(ArrayHelper, ArrayProp-&gt;Inner, SortProperty, 0, ArrayHelper.Num() - 1, bAscending); } } (4) cpp文件，快排递归循环 void UGenericArrayLibrary::QuickSort_RecursiveByProperty(FScriptArrayHelper&amp; ArrayHelper, UProperty* InnerProp, UProperty* SortProp, int32 Low, int32 High, bool bAscending) { if (Low &lt; High) { int32 Pivot = QuickSort_PartitionByProperty(ArrayHelper, InnerProp, SortProp, Low, High, bAscending); QuickSort_RecursiveByProperty(ArrayHelper, InnerProp, SortProp, Low, Pivot - 1, bAscending); QuickSort_RecursiveByProperty(ArrayHelper, InnerProp, SortProp, Pivot + 1, High, bAscending); } } (5) cpp文件，快排拆分 int32 UGenericArrayLibrary::QuickSort_PartitionByProperty(FScriptArrayHelper&amp; ArrayHelper, UProperty* InnerProp, UProperty* SortProp, int32 Low, int32 High, bool bAscending) { int32 i = Low - 1; for (int32 j = Low; j &lt; High; j++) { if (GenericComparePropertyValue(ArrayHelper, InnerProp, SortProp, j, High, bAscending)) { i++; ArrayHelper.SwapValues(i, j); } } ArrayHelper.SwapValues(i + 1, High); return i + 1; } (6) cpp文件，比较数组中下标为j和High的成员大小 bool UGenericArrayLibrary::GenericComparePropertyValue(FScriptArrayHelper&amp; ArrayHelper, UProperty* InnerProp, UProperty* SortProp, int32 j, int32 High, bool bAscending) { bool bResult = false; void* LeftValueAddr = nullptr; void* RightValueAddr = nullptr; if (const UObjectProperty* ObjectProperty = Cast&lt;const UObjectProperty&gt;(InnerProp)) { UObject* LeftObject = ObjectProperty-&gt;GetObjectPropertyValue(ArrayHelper.GetRawPtr(j)); UObject* RightObject = ObjectProperty-&gt;GetObjectPropertyValue(ArrayHelper.GetRawPtr(High)); LeftValueAddr = SortProp-&gt;ContainerPtrToValuePtr&lt;void&gt;(LeftObject); RightValueAddr = SortProp-&gt;ContainerPtrToValuePtr&lt;void&gt;(RightObject); } else { LeftValueAddr = SortProp-&gt;ContainerPtrToValuePtr&lt;void&gt;(ArrayHelper.GetRawPtr(j)); RightValueAddr = SortProp-&gt;ContainerPtrToValuePtr&lt;void&gt;(ArrayHelper.GetRawPtr(High)); } if (const UNumericProperty* NumericProp = Cast&lt;const UNumericProperty&gt;(SortProp)) { if (NumericProp-&gt;IsFloatingPoint()) { bResult = NumericProp-&gt;GetFloatingPointPropertyValue(LeftValueAddr) &lt; NumericProp-&gt;GetFloatingPointPropertyValue(RightValueAddr); } else if (NumericProp-&gt;IsInteger()) { bResult = NumericProp-&gt;GetSignedIntPropertyValue(LeftValueAddr) &lt; NumericProp-&gt;GetSignedIntPropertyValue(RightValueAddr); } } else if (const UBoolProperty* BoolProp = Cast&lt;const UBoolProperty&gt;(SortProp)) { bResult = !BoolProp-&gt;GetPropertyValue(LeftValueAddr) &amp;&amp; BoolProp-&gt;GetPropertyValue(RightValueAddr); } else if (const UNameProperty* NameProp = Cast&lt;const UNameProperty&gt;(SortProp)) { bResult = NameProp-&gt;GetPropertyValue(LeftValueAddr).ToString() &lt; NameProp-&gt;GetPropertyValue(RightValueAddr).ToString(); } else if (const UStrProperty* StringProp = Cast&lt;const UStrProperty&gt;(SortProp)) { bResult = (StringProp-&gt;GetPropertyValue(LeftValueAddr) &lt; StringProp-&gt;GetPropertyValue(RightValueAddr)); } else if (const UTextProperty* TextProp = Cast&lt;const UTextProperty&gt;(SortProp)) { bResult = (TextProp-&gt;GetPropertyValue(LeftValueAddr).ToString() &lt; TextProp-&gt;GetPropertyValue(RightValueAddr).ToString()); } return bResult == bAscending; } （7）为了使Array_Sort节点适用BP UStruct (蓝图结构体)数组，将内置的FindField()函数做了部分修改。 namespace SortAlgorithm { template &lt;class T&gt; T* FindField(const UStruct* Owner, FName FieldName) { // We know that a &quot;none&quot; field won't exist in this Struct if (FieldName.IsNone()) { return nullptr; } // Search by comparing FNames (INTs), not strings for (TFieldIterator&lt;T&gt;It(Owner); It; ++It) { if (It-&gt;GetFName() == FieldName) { return *It; } FName PropertyName = It-&gt;GetFName(); //PropertyName of USTRUCT(struct is defined in Blueprint) will contains invalid string, //such as &quot;Name_6_9093759148F93FCBBBF96AB8D348EC58&quot;. if (PropertyName.ToString().Contains(FieldName.ToString(), ESearchCase::IgnoreCase, ESearchDir::FromStart)) { return *It; } } // If we didn't find it, return no field return nullptr; } } 4. Usage 上述代码编译成功后，可在蓝图图表中找到以上二个SORT节点。 下面以float 数组为例，进行简单测试，以对比Sort by Propery和Sort by Function和Sort（STL）三种方式排序时间的差异; 随机获取一个浮点型数组，分别调用SORT节点，并打印排序时间 Print Duration宏蓝图代码如下 Sort by Function的SortBy函数应包含二个输入参数（变量类型与数组成员类型相同），以及一个名为ReturnValue（bool）的返回值，以上float数组的SortBy函数如下所示： 执行结果 Length Quick Sorty by Function Quick Sorty by Property Sort by STL 100 0~1(ms) 0(ms) 0(ms) 1000 12~16(ms) 0~1(ms) 0~1(ms) 10000 164~182(ms) 2~4(ms) 0~1(ms) 100000 2181~2365(ms) 34~40(ms) 2~7(ms) 小结： 效率高低次序：STL &gt; Sort by Propery &gt;&gt; Sort by Function; 当数组长度length&lt;100时，三种排序方法在时间上没有明显差异，均可适用；当数length&lt;10000时，使用Sort by Propery和Sort by STL二种进行排序没有明显差异。 由于Sort by Function排序方法使用了动态内存分配，并且调用了蓝图函数（SortBy），故效率最低；也正是因为使用蓝图函数比较大小，因此适用性更广，如二个以上排序变量的情形。 5. Conclusion 本文主要介绍了二种 UE4 泛型数组快速排序的蓝图节点的实现方法。经测试，该泛型蓝图排序节点性能虽然仍低于STL中的排序方法，但二者已处于同一层级。 ","link":"https://xusjtuer.github.io/post/ue4-post2_generic_array_quick_sort/"},{"title":"UE4 Blueprint蓝图实现任意类型数组排序","content":"蓝图实现任意类型数组排序 Implementation of wildcard array sort in blueprint 1. Overview ​本教程旨在讲解在虚幻引擎(UE4)蓝图（blueprint）中实现任意类型的数组排序，也就是实现泛型数组排序，在UE4的蓝图系统中用Wildcard（通配符）表示泛型。本教程基于选择排序（Selection Sort）和冒泡排序（Bubble Sort）原理，利用蓝图宏，实现了对任意类型数组（Generic TArray）排序的蓝图宏节点。 2. Required Knowledge ​ (1) 基本熟悉ue4，了解蓝图宏库（Blueprint Macro Library）的创建方法； ​ (2) Selection Sort 和 Bubble Sort 排序原理； 3. Why ​UE4的蓝图系统并未内置数组排序（Array Sort）的蓝图节点，但是对数组进行排序可以说是开发中无可避免的问题。虽然在使用C++进行开发时，可以轻易调用C++ STL的排序算法，并使用宏UFUNCTION(BlueprintCallable)，将其暴露给蓝图；但是这种处理方式，对于随时新增加的类型（UStruct/UObject派生类），每一种类型的数据都要自定义一个C++版排序函数。既耗费了不必要代码修改和编译时间，又增加了代码冗余。 如果可以用一个节点来完成对任意类型数组排序，显然有极大的好处。 此外，虽然可以在UE4 C++中使用Wildcard 变量来实现数组排序，但是其实现过程较为复杂、繁琐，门框过高。还可能存在适用性的问题，可能无法同时对int，float，struct，object及其派生类（Actor）等都适用。 4. Sort Approach （1）创建蓝图宏库，鼠标右键-&gt;Blueprints-&gt;Blueprint Macro Library -&gt;All Classes-&gt;Object，以UObject作为蓝图宏库的基类。 （2）My Blueprint窗口，Add New创建二个宏Select Sort、Bubble Sort； （3）选择排序（Select Sort） Description： 选择排序(详情请查阅选择排序方法) bGreater=( Array[min] &gt;Array[i] ) ? true : false; 将Array[min]与Array[i]成员的大小比较结果连接上bGreater(pin) 内部循环根据bGreater(bool)值判断是否交换Array[min]与Array[i]成员位置 排序结束，返回有序数组 图1. 选择排序细节面板，（Array Pin 勾选Pass-by-Reference，以引用方式传递数据）； 选择排序（Selection Sort）蓝图宏实现方法 图2. 选择排序蓝图宏； （4）冒泡排序（Bubble Sort） ​ Description：冒泡排序(详情请查阅冒泡排序方法) ​ bGreater=( Array[j] &gt;Array[j+1] ) ? true : false; ​ 将Array[j]与Array[j+1]的大小比较结果连接上bGreater(pin) ​ 内部循环根据bGreater(bool)值判断是否交换Array[j]与Array[j+1]成员位置 ​ 排序结束，返回有序数组 图3. 冒泡排序细节面板，（Array Pin 勾选Pass-by-Reference，以引用方式传递数据）； 冒泡排序（Bubble Sort）蓝图宏实现方法! 图4. 冒泡排序蓝图宏； 5. Usage （1）以上第4步完成，即可任意蓝图中，context menu中输入sort关键词即可查找二个节点； 图5. 从蓝图中查找Bubble Sort/Selection Sort节点； （2）任意类型数组引脚（pin）连接示例，下图以Bubble Sort节点为例，并随意选取Actor、Struct、Float、Int类型数组； 图6. 不同类型数组排序示例； （3）排序节点连接方式示例，（数组元素类型必须包含可排序得变量，如float/int类型变量）； 图7. Item数组排序示例，Score变量为本例排序指定关键字； （4）排序方向，升序/降序示例 图8. a. 返回升序数组； 图9. b. 返回降序数组； （5）二个以上排序变量蓝图引脚连接示例，该类情形最好自定义一个比较函数（Pure函数），如下图所示 图10. 蓝图引脚连接示例； 图11. 二个排序排序变量，大小比较方法示例，并该函数设置成Pure； 6. Shortage 由于冒泡排序和选择排序本身就属于低效的排序算法，此外相较于c++，蓝图执行效率差得多，因此以上二个蓝图泛型排序节点应当只用于长度较小的数组排序（length&lt;100）。若数组长度超过一定值时，会产生明显的卡顿，甚至会直接停止运行，并显示以下错误提示。 LogScript: Warning: Runaway loop detected (over 1,000,000 iterations) - see log for stack trace BP_HttpActotr_C /Game/Maps/UEDPIE_0_BeginMap.BeginMap:PersistentLevel.BP_HttpActotr_2 Function /Game/Blueprints/BP_HttpActotr.BP_HttpActotr_C:ExecuteUbergraph_BP_HttpActotr:0250 PIE: Error: Infinite loop detected. Blueprint: BP_HttpActotr Function: Branch Call Stack: Show 7. Conclusion 本文主要介绍使用UE4 蓝图宏实现任意类型数组排序的蓝图节点，可以在数组长度较小的情形下，对数组进行排序。由于排序算法和蓝图节点执行的效率均比较低，因此不建议在数组长度大的情形，使用以上节点进行排序。 原创文章，未经允许，禁止转载 ","link":"https://xusjtuer.github.io/post/ue4-post1_generic_array_sort_macro/"}]}