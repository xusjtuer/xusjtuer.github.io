{"posts":[{"title":"UE4 C++实现任意类型数组蓝图排序节点（Quick Sort）","content":"1. Overview 本教程旨在讲解在虚幻引擎(UE4) C++中实现蓝图(Blueprint)可调用的任意类型数组排序的蓝图节点。纯蓝图方法实现任意类型数组排序方法，请查看上一期 UE4 蓝图实现任意类型数组排序。以下泛型数组排序节点Array_Sort基于快速排序算法（Quick Sort）原理，冒泡排序（Bubble Sort）版见知乎链接：第2期 UE4 C++实现任意类型数组蓝图排序节点。编者水平有限，如有错漏敬请谅解。 2. Introduction 快速排序（Quick Sort）的平均时间复杂度为O(nlog2n)，冒泡排序（Bubble Sort）的平均时间复杂度为O(n2)，若以时间复杂度作为评价二种排序算法的优劣标准的话，快速排序明显优于冒泡排序。所以在已经介绍了冒泡版泛型数组排序方法，再次补充一个快速排序版泛型数组排序方法。同样地，以Sort by Function和Sort by Property作为比较数组成员大小的二种方式，分别编写了Sort Array by Function和Sort Array by Proerty二个泛型数组排序节点。 本文主要讲解UE4 C++泛型数组的快速排序蓝图节点的实现方法，以及该泛型快排节点与STL 排序方法的比较。 3. Sort Approach 3.1 基于SortBy Function，实现泛型数组排序 (1) h文件，Array_Sort函数声明： /** Generic sort array by function using quick sort algorithm. * * @param Array Target array to sort * @param Object The owner of CompareBy function,(DefaultToSelf) * @param SortBy Function name of overloads operator &quot;&lt;&quot; function The signature of the comparison function should be equivalent to the following: bool cmp(const Type1 &amp;a, const Type2 &amp;b); return value should named &quot;ReturnValue&quot;(bool) */ UFUNCTION(BlueprintCallable, CustomThunk, meta = (DisplayName = &quot;Sort Array by Function&quot;, CompactNodeTitle = &quot;Sort&quot;, ArrayParm = &quot;Array&quot;, AutoCreateRefTerm = &quot;Array&quot;, DefaultToSelf = &quot;Object&quot;, AdvancedDisplay = &quot;Object&quot;), Category = &quot;Utilities|Array&quot;) static void Array_SortV1(const TArray&lt;int32&gt;&amp; Array, UObject* Object, FName SortBy); // generic quick sort array by function name static void GenericArray_SortByFunction(UObject* OwnerObject, UFunction* ComparedBy, void* TargetArray, UArrayProperty* ArrayProp); // Low --&gt; Starting index, High --&gt; Ending index static void QuickSortByFunction_Recursive(UObject* OwnerObject, UFunction* ComparedBy, UProperty* InnerProp, FScriptArrayHelper&amp; ArrayHelper, int32 Low, int32 High); // swapping items in place and partitioning the section of an array static int32 QuickSortByFunction_Partition(UObject* OwnerObject, UFunction* ComparedBy, UProperty* InnerProp, FScriptArrayHelper&amp; ArrayHelper, int32 Low, int32 High); // Check that the CompareBy function is appropriate static bool IsSuitableFunction(UFunction* ComparedBy, UArrayProperty* ArrayProp); (2) h文件，Array_SortV1函数的自定义CustomThunk函数体 // sort array by function name DECLARE_FUNCTION(execArray_SortV1) { Stack.MostRecentProperty = nullptr; Stack.StepCompiledIn&lt;UArrayProperty&gt;(NULL); void* ArrayAAddr = Stack.MostRecentPropertyAddress; UArrayProperty* ArrayProperty = Cast&lt;UArrayProperty&gt;(Stack.MostRecentProperty); if (!ArrayProperty) { Stack.bArrayContextFailed = true; return; } P_GET_OBJECT(UObject, OwnerObject); P_GET_PROPERTY(UNameProperty, SortBy); if (!OwnerObject) { return; } UFunction* const SortFunction = OwnerObject-&gt;FindFunction(SortBy); if ((!SortFunction || (SortFunction-&gt;NumParms != 3))) { return; } P_FINISH; P_NATIVE_BEGIN; GenericArray_SortByFunction(OwnerObject, SortFunction, ArrayAAddr, ArrayProperty); P_NATIVE_END; } (3) cpp文件，GenericArray_SortByFunction()函数体 void UGenericArrayLibrary::GenericArray_SortByFunction(UObject* OwnerObject, UFunction* ComparedBy, void* TargetArray, UArrayProperty* ArrayProp) { if (!ComparedBy || !OwnerObject || !TargetArray) { return; } else if (!IsSuitableFunction(ComparedBy, ArrayProp)) { return; } // Optimal UKismetArrayLibrary::GenericArray_Shuffle(TargetArray, ArrayProp); // Begin sort array FScriptArrayHelper ArrayHelper(ArrayProp, TargetArray); if (ArrayHelper.Num() &lt; 2) { return; } else { UProperty* InnerProp = ArrayProp-&gt;Inner; QuickSortByFunction_Recursive(OwnerObject, ComparedBy, InnerProp, ArrayHelper, 0, ArrayHelper.Num() - 1); } } 其中，快排算法优化： // Optimal UKismetArrayLibrary::GenericArray_Shuffle(TargetArray, ArrayProp); (4) cpp文件，快排递归循环 void UGenericArrayLibrary::QuickSortByFunction_Recursive(UObject* OwnerObject, UFunction* ComparedBy, UProperty* InnerProp, FScriptArrayHelper&amp; ArrayHelper, int32 Low, int32 High) { if (Low &lt; High) { int32 Pivot = QuickSortByFunction_Partition(OwnerObject, ComparedBy, InnerProp, ArrayHelper, Low, High); QuickSortByFunction_Recursive(OwnerObject, ComparedBy, InnerProp, ArrayHelper, Low, Pivot - 1); QuickSortByFunction_Recursive(OwnerObject, ComparedBy, InnerProp, ArrayHelper, Pivot + 1, High); } } (5) cpp文件，快排拆分 int32 UGenericArrayLibrary::QuickSortByFunction_Partition(UObject* OwnerObject, UFunction* ComparedBy, UProperty* InnerProp, FScriptArrayHelper&amp; ArrayHelper, int32 Low, int32 High) { const int32 PropertySize = InnerProp-&gt;ElementSize * InnerProp-&gt;ArrayDim; UBoolProperty* ReturnProp = Cast&lt;UBoolProperty&gt;(ComparedBy-&gt;GetReturnProperty()); // CompareBy function parameters address, 2 input parameter(array item) and 1 return parameter (bool) uint8* FuncParamsAddr = (uint8*)FMemory::Malloc(ComparedBy-&gt;ParmsSize); /// note:ParamsSize = PropertySize* 2 +1 FMemory::Memzero(FuncParamsAddr, ComparedBy-&gt;ParmsSize); /** Based on quick sort of stl */ InnerProp-&gt;CopyCompleteValueFromScriptVM(FuncParamsAddr, ArrayHelper.GetRawPtr(High)); //Params1: LastSmallElem = Array[High] int32 i = Low - 1; for (int32 j = Low; j &lt; High; j++) { InnerProp-&gt;CopyCompleteValueFromScriptVM(FuncParamsAddr + PropertySize, ArrayHelper.GetRawPtr(j)); // Param2: Array[i] OwnerObject-&gt;ProcessEvent(ComparedBy, FuncParamsAddr); if (ReturnProp &amp;&amp; ReturnProp-&gt;GetPropertyValue(FuncParamsAddr + PropertySize * 2)) { i++; ArrayHelper.SwapValues(i, j); } } ArrayHelper.SwapValues(i + 1, High); // release memory FMemory::Free(FuncParamsAddr); return i + 1; } (6) cpp文件，判断用于比较数组元素大小的蓝图函数是否合乎要求 bool UGenericArrayLibrary::IsSuitableFunction(UFunction* ComparedBy, UArrayProperty* ArrayProp) { // check CompareBy function's parameter number if ((!ComparedBy || (ComparedBy-&gt;NumParms != 3))) { UE_LOG(LogTemp, Warning, TEXT(&quot;IsSuitableFunction -&gt; CompareBy function should only have 3 parameters !&quot;)); return false; } //Get return property of CompareBy function. UBoolProperty* ReturnProp = Cast&lt;UBoolProperty&gt;(ComparedBy-&gt;GetReturnProperty()); if (!ReturnProp) { /// The return Property of max function must be bool and named &quot;ReturnValue&quot; UE_LOG(LogTemp, Warning, TEXT(&quot;IsSuitableFunction -&gt; Return value of CompareBy function should be bool type, and named ReturnValue.&quot;)); return false; } // Get all parameters of CompareBy function TArray&lt;UProperty*&gt; ParamterList; for (TFieldIterator&lt;UProperty&gt; It(ComparedBy); It; ++It) { UProperty* FuncParameter = *It; ParamterList.Emplace(FuncParameter); } // Make sure the first/second input parameters of Compare function is same to array inner if (!ParamterList[0]-&gt;SameType(ArrayProp-&gt;Inner) || !ParamterList[1]-&gt;SameType(ArrayProp-&gt;Inner)) { /// The property of 1st input parameter of max function must be same as array member UE_LOG(LogTemp, Warning, TEXT(&quot;IsSuitableFunction -&gt; The parameters type of CompareBy should be same to array member.&quot;)); return false; } return true; } 3.2 基于SortBy Property，实现泛型数组排序 (1) h文件，Array_Sort函数声明： /** Generic sort array by property using quick sort algorithm. * * @param Array Target array to sort * @param PropertyName Name is the variable to sort by for struct or object array. Otherwise, the parameter is ignored. * @param bAscending If true, sort by ascending order. */ UFUNCTION(BlueprintCallable, CustomThunk, meta = (DisplayName = &quot;Sort Array by Property&quot;, CompactNodeTitle = &quot;Sort&quot;, ArrayParm = &quot;Array&quot;, AutoCreateRefTerm = &quot;Array&quot;, bAscending = &quot;true&quot;), Category = &quot;Utilities|Array&quot;) static void Array_SortV2(const TArray&lt;int32&gt;&amp; Array, FName PropertyName, bool bAscending); // generic quick sort array by property static void GenericArray_SortV2(void* TargetArray, UArrayProperty* ArrayProp, FName PropertyName, bool bAscending); // Low --&gt; Starting index, High --&gt; Ending index static void QuickSort_RecursiveByProperty(FScriptArrayHelper&amp; ArrayHelper, UProperty* InnerProp, UProperty* SortProp, int32 Low, int32 High, bool bAscending); // swapping items in place and partitioning the section of an array static int32 QuickSort_PartitionByProperty(FScriptArrayHelper&amp; ArrayHelper, UProperty* InnerProp, UProperty* SortProp, int32 Low, int32 High, bool bAscending); // generic compare two element of array by property static bool GenericComparePropertyValue(FScriptArrayHelper&amp; ArrayHelper, UProperty* InnerProp, UProperty* SortProp, int32 j, int32 High, bool bAscending); (2) h文件，Array_SortV2函数的自定义CustomThunk函数体 // sort array by property DECLARE_FUNCTION(execArray_SortV2) { Stack.MostRecentProperty = nullptr; Stack.StepCompiledIn&lt;UArrayProperty&gt;(NULL); void* ArrayAddr = Stack.MostRecentPropertyAddress; UArrayProperty* ArrayProperty = Cast&lt;UArrayProperty&gt;(Stack.MostRecentProperty); if (!ArrayProperty) { Stack.bArrayContextFailed = true; return; } P_GET_PROPERTY(UNameProperty, PropertyName); P_GET_UBOOL(bAscending); P_FINISH; P_NATIVE_BEGIN; GenericArray_SortV2(ArrayAddr, ArrayProperty, PropertyName, bAscending); P_NATIVE_END; } (3) cpp文件，GenericArray_SortV2()函数体 void UGenericArrayLibrary::GenericArray_SortV2(void* TargetArray, UArrayProperty* ArrayProp, FName PropertyName, bool bAscending) { if (!TargetArray) { return; } // Optimal UKismetArrayLibrary::GenericArray_Shuffle(TargetArray, ArrayProp); FScriptArrayHelper ArrayHelper(ArrayProp, TargetArray); UProperty* SortProperty = nullptr; if (ArrayHelper.Num() &lt; 2) { return; } else if (const UObjectProperty* ObjectProperty = Cast&lt;const UObjectProperty&gt;(ArrayProp-&gt;Inner)) { SortProperty = FindField&lt;UProperty&gt;(ObjectProperty-&gt;PropertyClass, PropertyName); } else if (const UStructProperty* StructProperty = Cast&lt;const UStructProperty&gt;(ArrayProp-&gt;Inner)) { SortProperty = SortAlgorithm::FindField&lt;UProperty&gt;(StructProperty-&gt;Struct, PropertyName); } else { SortProperty = ArrayProp-&gt;Inner; } if (SortProperty) { QuickSort_RecursiveByProperty(ArrayHelper, ArrayProp-&gt;Inner, SortProperty, 0, ArrayHelper.Num() - 1, bAscending); } } (4) cpp文件，快排递归循环 void UGenericArrayLibrary::QuickSort_RecursiveByProperty(FScriptArrayHelper&amp; ArrayHelper, UProperty* InnerProp, UProperty* SortProp, int32 Low, int32 High, bool bAscending) { if (Low &lt; High) { int32 Pivot = QuickSort_PartitionByProperty(ArrayHelper, InnerProp, SortProp, Low, High, bAscending); QuickSort_RecursiveByProperty(ArrayHelper, InnerProp, SortProp, Low, Pivot - 1, bAscending); QuickSort_RecursiveByProperty(ArrayHelper, InnerProp, SortProp, Pivot + 1, High, bAscending); } } (5) cpp文件，快排拆分 int32 UGenericArrayLibrary::QuickSort_PartitionByProperty(FScriptArrayHelper&amp; ArrayHelper, UProperty* InnerProp, UProperty* SortProp, int32 Low, int32 High, bool bAscending) { int32 i = Low - 1; for (int32 j = Low; j &lt; High; j++) { if (GenericComparePropertyValue(ArrayHelper, InnerProp, SortProp, j, High, bAscending)) { i++; ArrayHelper.SwapValues(i, j); } } ArrayHelper.SwapValues(i + 1, High); return i + 1; } (6) cpp文件，比较数组中下标为j和High的成员大小 bool UGenericArrayLibrary::GenericComparePropertyValue(FScriptArrayHelper&amp; ArrayHelper, UProperty* InnerProp, UProperty* SortProp, int32 j, int32 High, bool bAscending) { bool bResult = false; void* LeftValueAddr = nullptr; void* RightValueAddr = nullptr; if (const UObjectProperty* ObjectProperty = Cast&lt;const UObjectProperty&gt;(InnerProp)) { UObject* LeftObject = ObjectProperty-&gt;GetObjectPropertyValue(ArrayHelper.GetRawPtr(j)); UObject* RightObject = ObjectProperty-&gt;GetObjectPropertyValue(ArrayHelper.GetRawPtr(High)); LeftValueAddr = SortProp-&gt;ContainerPtrToValuePtr&lt;void&gt;(LeftObject); RightValueAddr = SortProp-&gt;ContainerPtrToValuePtr&lt;void&gt;(RightObject); } else { LeftValueAddr = SortProp-&gt;ContainerPtrToValuePtr&lt;void&gt;(ArrayHelper.GetRawPtr(j)); RightValueAddr = SortProp-&gt;ContainerPtrToValuePtr&lt;void&gt;(ArrayHelper.GetRawPtr(High)); } if (const UNumericProperty* NumericProp = Cast&lt;const UNumericProperty&gt;(SortProp)) { if (NumericProp-&gt;IsFloatingPoint()) { bResult = NumericProp-&gt;GetFloatingPointPropertyValue(LeftValueAddr) &lt; NumericProp-&gt;GetFloatingPointPropertyValue(RightValueAddr); } else if (NumericProp-&gt;IsInteger()) { bResult = NumericProp-&gt;GetSignedIntPropertyValue(LeftValueAddr) &lt; NumericProp-&gt;GetSignedIntPropertyValue(RightValueAddr); } } else if (const UBoolProperty* BoolProp = Cast&lt;const UBoolProperty&gt;(SortProp)) { bResult = !BoolProp-&gt;GetPropertyValue(LeftValueAddr) &amp;&amp; BoolProp-&gt;GetPropertyValue(RightValueAddr); } else if (const UNameProperty* NameProp = Cast&lt;const UNameProperty&gt;(SortProp)) { bResult = NameProp-&gt;GetPropertyValue(LeftValueAddr).ToString() &lt; NameProp-&gt;GetPropertyValue(RightValueAddr).ToString(); } else if (const UStrProperty* StringProp = Cast&lt;const UStrProperty&gt;(SortProp)) { bResult = (StringProp-&gt;GetPropertyValue(LeftValueAddr) &lt; StringProp-&gt;GetPropertyValue(RightValueAddr)); } else if (const UTextProperty* TextProp = Cast&lt;const UTextProperty&gt;(SortProp)) { bResult = (TextProp-&gt;GetPropertyValue(LeftValueAddr).ToString() &lt; TextProp-&gt;GetPropertyValue(RightValueAddr).ToString()); } return bResult == bAscending; } （7）为了使Array_Sort节点适用BP UStruct (蓝图结构体)数组，将内置的FindField()函数做了部分修改。 namespace SortAlgorithm { template &lt;class T&gt; T* FindField(const UStruct* Owner, FName FieldName) { // We know that a &quot;none&quot; field won't exist in this Struct if (FieldName.IsNone()) { return nullptr; } // Search by comparing FNames (INTs), not strings for (TFieldIterator&lt;T&gt;It(Owner); It; ++It) { if (It-&gt;GetFName() == FieldName) { return *It; } FName PropertyName = It-&gt;GetFName(); //PropertyName of USTRUCT(struct is defined in Blueprint) will contains invalid string, //such as &quot;Name_6_9093759148F93FCBBBF96AB8D348EC58&quot;. if (PropertyName.ToString().Contains(FieldName.ToString(), ESearchCase::IgnoreCase, ESearchDir::FromStart)) { return *It; } } // If we didn't find it, return no field return nullptr; } } 4. Usage 上述代码编译成功后，可在蓝图图表中找到以上二个SORT节点。 下面以float 数组为例，进行简单测试，以对比Sort by Propery和Sort by Function和Sort（STL）三种方式排序时间的差异; 随机获取一个浮点型数组，分别调用SORT节点，并打印排序时间 Print Duration宏蓝图代码如下 Sort by Function的SortBy函数应包含二个输入参数（变量类型与数组成员类型相同），以及一个名为ReturnValue（bool）的返回值，以上float数组的SortBy函数如下所示： 执行结果 Length Quick Sorty by Function Quick Sorty by Property Sort by STL 100 0~1(ms) 0(ms) 0(ms) 1000 12~16(ms) 0~1(ms) 0~1(ms) 10000 164~182(ms) 2~4(ms) 0~1(ms) 100000 2181~2365(ms) 34~40(ms) 2~7(ms) 小结： 效率高低次序：STL &gt; Sort by Propery &gt;&gt; Sort by Function; 当数组长度length&lt;100时，三种排序方法在时间上没有明显差异，均可适用；当数length&lt;10000时，使用Sort by Propery和Sort by STL二种进行排序没有明显差异。 由于Sort by Function排序方法使用了动态内存分配，并且调用了蓝图函数（SortBy），故效率最低；也正是因为使用蓝图函数比较大小，因此适用性更广，如二个以上排序变量的情形。 5. Conclusion 本文主要介绍了二种 UE4 泛型数组快速排序的蓝图节点的实现方法。经测试，该泛型蓝图排序节点性能虽然仍低于STL中的排序方法，但二者已处于同一层级。 ","link":"https://xusjtuer.github.io/post/ue4-cshi-xian-ren-yi-lei-xing-shu-zu-lan-tu-pai-xu-jie-dian/"},{"title":"UE4 蓝图实现任意类型数组排序","content":"蓝图实现任意类型数组排序 Implementation of wildcard array sort in blueprint 1. Overview ​本教程旨在讲解在虚幻引擎(UE4)蓝图（blueprint）中实现任意类型的数组排序，也就是实现泛型数组排序，在UE4的蓝图系统中用Wildcard（通配符）表示泛型。本教程基于选择排序（Selection Sort）和冒泡排序（Bubble Sort）原理，利用蓝图宏，实现了对任意类型数组（Generic TArray）排序的蓝图宏节点。 2. Required Knowledge ​ (1) 基本熟悉ue4，了解蓝图宏库（Blueprint Macro Library）的创建方法； ​ (2) Selection Sort 和 Bubble Sort 排序原理； 3. Why ​UE4的蓝图系统并未内置数组排序（Array Sort）的蓝图节点，但是对数组进行排序可以说是开发中无可避免的问题。虽然在使用C++进行开发时，可以轻易调用C++ STL的排序算法，并使用宏UFUNCTION(BlueprintCallable)，将其暴露给蓝图；但是这种处理方式，对于随时新增加的类型（UStruct/UObject派生类），每一种类型的数据都要自定义一个C++版排序函数。既耗费了不必要代码修改和编译时间，又增加了代码冗余。 如果可以用一个节点来完成对任意类型数组排序，显然有极大的好处。 此外，虽然可以在UE4 C++中使用Wildcard 变量来实现数组排序，但是其实现过程较为复杂、繁琐，门框过高。还可能存在适用性的问题，可能无法同时对int，float，struct，object及其派生类（Actor）等都适用。 4. Sort Approach （1）创建蓝图宏库，鼠标右键-&gt;Blueprints-&gt;Blueprint Macro Library -&gt;All Classes-&gt;Object，以UObject作为蓝图宏库的基类。 （2）My Blueprint窗口，Add New创建二个宏Select Sort、Bubble Sort； （3）选择排序（Select Sort） Description： 选择排序(详情请查阅选择排序方法) bGreater=( Array[min] &gt;Array[i] ) ? true : false; 将Array[min]与Array[i]成员的大小比较结果连接上bGreater(pin) 内部循环根据bGreater(bool)值判断是否交换Array[min]与Array[i]成员位置 排序结束，返回有序数组 图1. 选择排序细节面板，（Array Pin 勾选Pass-by-Reference，以引用方式传递数据）； 选择排序（Selection Sort）蓝图宏实现方法 图2. 选择排序蓝图宏； （4）冒泡排序（Bubble Sort） ​ Description：冒泡排序(详情请查阅冒泡排序方法) ​ bGreater=( Array[j] &gt;Array[j+1] ) ? true : false; ​ 将Array[j]与Array[j+1]的大小比较结果连接上bGreater(pin) ​ 内部循环根据bGreater(bool)值判断是否交换Array[j]与Array[j+1]成员位置 ​ 排序结束，返回有序数组 图3. 冒泡排序细节面板，（Array Pin 勾选Pass-by-Reference，以引用方式传递数据）； 冒泡排序（Bubble Sort）蓝图宏实现方法! 图4. 冒泡排序蓝图宏； 5. Usage （1）以上第4步完成，即可任意蓝图中，context menu中输入sort关键词即可查找二个节点； 图5. 从蓝图中查找Bubble Sort/Selection Sort节点； （2）任意类型数组引脚（pin）连接示例，下图以Bubble Sort节点为例，并随意选取Actor、Struct、Float、Int类型数组； 图6. 不同类型数组排序示例； （3）排序节点连接方式示例，（数组元素类型必须包含可排序得变量，如float/int类型变量）； 图7. Item数组排序示例，Score变量为本例排序指定关键字； （4）排序方向，升序/降序示例 图8. a. 返回升序数组； 图9. b. 返回降序数组； （5）二个以上排序变量蓝图引脚连接示例，该类情形最好自定义一个比较函数（Pure函数），如下图所示 图10. 蓝图引脚连接示例； 图11. 二个排序排序变量，大小比较方法示例，并该函数设置成Pure； 6. Shortage 由于冒泡排序和选择排序本身就属于低效的排序算法，此外相较于c++，蓝图执行效率差得多，因此以上二个蓝图泛型排序节点应当只用于长度较小的数组排序（length&lt;100）。若数组长度超过一定值时，会产生明显的卡顿，甚至会直接停止运行，并显示以下错误提示。 LogScript: Warning: Runaway loop detected (over 1,000,000 iterations) - see log for stack trace BP_HttpActotr_C /Game/Maps/UEDPIE_0_BeginMap.BeginMap:PersistentLevel.BP_HttpActotr_2 Function /Game/Blueprints/BP_HttpActotr.BP_HttpActotr_C:ExecuteUbergraph_BP_HttpActotr:0250 PIE: Error: Infinite loop detected. Blueprint: BP_HttpActotr Function: Branch Call Stack: Show 7. Conclusion 本文主要介绍使用UE4 蓝图宏实现任意类型数组排序的蓝图节点，可以在数组长度较小的情形下，对数组进行排序。由于排序算法和蓝图节点执行的效率均比较低，因此不建议在数组长度大的情形，使用以上节点进行排序。 原创文章，未经允许，禁止转载 ","link":"https://xusjtuer.github.io/post/ue4-dong-tai-du-xie-datatable-shu-ju-biao/"}]}